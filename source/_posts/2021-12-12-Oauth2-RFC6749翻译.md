---
title: Oauth2-RFC6749翻译
date: 2021-12-12 17:50:54
updated: 2021-12-12 17:51:15
comments: true
tags:
  - Oauth2.0
  - RFC
categories:
  - RFC标准
---

转自: <https://github.com/jeansfish/RFC6749.zh-cn/blob/master/index.md>

互联网工程任务组（IETF，Internet Engineering Task Force）
RFC：6749
淘汰：[5849](http://tools.ietf.org/html/rfc5849) 类别：标准化过程
ISSN：2070-1721

D. Hardt, Ed.
Microsoft
2012年10月

## OAuth 2.0授权框架

### 摘要

OAuth2.0授权框架允许第三方应用获取对HTTP服务的有限的访问权限，既可以以资源所有者名义在资源所有者和HTTP服务之间进行允许的交互，也可以允许第三方应用以自己的名义进行访问。本规范取代并淘汰RFC5849中描述的OAuth 1.0协议。

### 本备忘录状态

这是一个互联网标准化过程文档。

本文档是互联网工程任务组（IETF）的作品。它代表了IETF 社区的一致看法。它已接受公开审阅并由互联网工程指导小组（IESG）批准公布。有关互联网标准的进一步信息可在[RFC5741的第2节](http://tools.ietf.org/html/rfc5741#section-2)找到。

有关本文档的当前状态、勘误表以及如何对它提供反馈可参见<http://www.rfc-editor.org/info/rfc6749>。

### 版权声明

IETF信托及标识为本文档的作者的个人版权所有（c）2012。保留所有权利。

本文档受[BCP78](http://tools.ietf.org/html/bcp78)和IETF信托有关[IETF文档的法律条款](http://trustee.ietf.org/license-info)的约束，自本文档发布之日起生效。请仔细查阅这些文件，因为它们描述了与本文档有关的权利和限制。从本文档中提取的代码组件必须按[信托法律条款4.e节](http://tools.ietf.org/html/rfc6749#section-4)所述包括简化BSD许可证文本；并且按简化BSD许可证中所述不附带质量保证。

## 1 介绍

在传统的客户端-服务器身份验证模式中，客户端请求服务器上访问受限的资源（受保护的资源）时，需要使用资源所有者的凭据在服务器上进行身份验证。
资源所有者为了给第三方应用提供受限资源的访问权限，需要与第三方共享它的凭据。这就导致一些问题和局限：

- 第三方应用需要存储资源所有者的凭据以供将来使用。该凭据通常是明文密码。
- 服务器需要支持密码身份认证，尽管密码认证有固有的安全缺陷。
- 第三方应用获得了对资源所有者的受保护资源的过于宽泛的访问权限，从而导致资源所有者不能限制对资源的有限子集的访问时限或权限。
- 资源所有者不能撤销某个第三方的访问权限而不影响其它第三方，并且必须更改他们的密码才能做到。
- 与任何第三方应用的妥协导致对终端用户的密码及该密码所保护的所有数据的妥协。

OAuth通过引入授权层以及从资源所有者角色分离出客户端角色来解决这些问题。在OAuth中，客户端请求对受资源所有者控制且托管在资源服务器上的资源的访问权限，并授予一组不同于资源所有者所拥有的凭据。

作为使用资源所有者的凭据访问受保护资源的替代，客户端获得一个访问令牌———一个代表特定作用域、生命周期以及其他访问权限属性的字符串。访问令牌由授权服务器在资源所有者认可的情况下颁发给第三方客户端。客户端使用访问令牌访问托管在资源服务器上的受保护资源。

例如，终端用户（资源所有者）可以许可一个打印服务（客户端）访问她存储在图片分享网站（资源服务器）上的受保护图片，而无需与打印服务分享自己的用户名和密码，而是，她直接与图片分享网站信任的服务器（授权服务器）进行身份验证，该服务器颁发给打印服务具体的委托凭据（访问令牌）。

本规范是为HTTP（[RFC2616](http://tools.ietf.org/html/rfc2616)）协议设计的。在任何非HTTP协议上使用OAuth不在本规范的范围之内。

OAuth 1.0协议（[RFC5849](http://tools.ietf.org/html/rfc5849)）作为一个指导性文档发布，是一个小的特设团体的工作成果。本标准化规范在OAuth 1.0的部署经验之上构建，也包括从更广泛的IETF社区收集到其他用户案例和可扩展性需求。OAuth 2.0协议不向后兼容OAuth 1.0。这两个版本可以在网络上共存，实现者可以选择同时支持他们。然而，本规范的用意是新的实现按本文档的规定支持Auth 2.0，OAuth 1.0仅用于支持现有的部署。OAuth 2.0协议与OAuth 1.0协议实现细节没有太多关联。熟悉OAuth 1.0的实现者应该理解本文档，而非对有关OAuth 2.0的结构和细节做任何假设。

### 1.1 角色

OAuth定义了四种角色：

- **资源所有者**
  能够许可对受保护资源的访问权限的实体。当资源所有者是个人时，它被称为最终用户。
- **资源服务器**
  托管受保护资源的服务器，能够接收和响应使用访问令牌对受保护资源的请求。
- **客户端**
  使用资源所有者的授权代表资源所有者发起对受保护资源的请求的应用程序。术语“客户端”并非特指任何特定的的实现特点（例如：应用程序是否是在服务器、台式机或其他设备上执行）。
- **授权服务器**
  在成功验证资源所有者且获得授权后颁发访问令牌给客户端的服务器。
  
授权服务器和资源服务器之间的交互超出了本规范的范围。授权服务器可以和资源服务器是同一台服务器，也可以是分离的个体。一个授权服务器可以颁发被多个资源服务器接受的访问令牌。

### 1.2 协议流程

```text
     +--------+                               +---------------+
     |        |--(A)- Authorization Request ->|   Resource    |
     |        |                               |     Owner     |
     |        |<-(B)-- Authorization Grant ---|               |
     |        |                               +---------------+
     |        |
     |        |                               +---------------+
     |        |--(C)-- Authorization Grant -->| Authorization |
     | Client |                               |     Server    |
     |        |<-(D)----- Access Token -------|               |
     |        |                               +---------------+
     |        |
     |        |                               +---------------+
     |        |--(E)----- Access Token ------>|    Resource   |
     |        |                               |     Server    |
     |        |<-(F)--- Protected Resource ---|               |
     +--------+                               +---------------+
```

图1：抽象的协议流程

图1中所示的抽象的OAuth 2.0流程描述了四种角色之间的交互，包括以下步骤：

- （A）客户端从资源所有者处请求授权。授权请求可以直接向资源所有者发起（如图所示），或者更可取的是通过授权服务器作为中介间接发起。
- （B）客户端收到授权许可，这是一个代表资源所有者的授权的凭据，使用本规范中定义的四种许可类型之一或者使用扩展许可类型表示。授权许可类型取决于客户端请求授权所使用的方法以及授权服务器支持的类型。
- （C）客户端与授权服务器进行身份认证并出示授权许可以请求访问令牌。
- （D）授权服务器验证客户端身份并验证授权许可，若有效则颁发访问令牌。
- （E）客户端从资源服务器请求受保护资源并出示访问令牌进行身份验证。
- （F）资源服务器验证访问令牌，若有效则处理该请求。

客户端从资源所有者获得授权许可（步骤（A）和（B）所示）的更好方法是使用授权服务器作为中介，如[4.1节](#4.1)图3所示。

### 1.3 授权许可

#### 1.3.1 授权码

#### 1.3.2 隐式授权

#### 1.3.3 资源所有者密码凭据

#### 1.3.4 客户端凭据

### 1.4 访问令牌

### 1.5 刷新令牌

### 1.6 TLS版本

### 1.7 HTTP重定向

### 1.8 互操作性

### 1.9 符号约定

## 2 客户端注册

### 2.1 客户端类型

### 2.2 客户端标识

### 2.3 客户端身份验证

#### 2.3.1 客户端密码

#### 2.3.2 其他身份验证方法

### 2.4 未注册的客户端

## 3 协议端点

### 3.1 授权端点

### 3.1.1 响应类型

### 3.1.2 重定向端点

## 3.2 令牌端点

### 3.2.1 客户端身份验证

## 3.3 访问令牌范围

## 4 获得授权

为了请求访问令牌，客户端从资源所有者获得授权。授权表现为授权许可的形式，客户端用它请求访问令牌。OAuth定义了四种许可类型：`授权码`、`隐式许可`、`资源所有者密码凭据`和`客户端凭据`。它还提供了扩展机制定义其他许可类型。

### 4.1 授权码许可

#### 4.1.1 授权请求

#### 4.1.2 授权响应

#### 4.1.3 访问令牌请求

#### 4.1.4 访问令牌响应

### 4.2 隐式许可

#### 4.2.1 授权请求

#### 4.2.2 访问令牌响应

### 4.3 资源所有者密码凭据许可

#### 4.3.1 授权请求和响应

#### 4.3.2 访问令牌请求

#### 4.3.3 访问令牌响应

### 4.4 客户端凭证许可

#### 4.4.1 授权请求和响应

#### 4.4.2 访问令牌请求

#### 4.4.3 访问令牌响应

### 4.5 扩展许可

## 5 颁发访问令牌

如果访问令牌请求是有效的且被授权，授权服务器如5.1节所述颁发访问令牌以及可选的刷新令牌。如果请求因客户端身份验证失败或无效，授权服务器如5.2节所述的返回错误响应。

### 5.1 成功响应

### 5.2 错误响应

## 6 刷新访问令牌

若授权服务器给客户端颁发了刷新令牌，客户端通过使用按[附录B](#AppendixB)“application/x-www-form-urlencoded”格式在HTTP请求实体正文中发送下列UTF-8字符编码的参数向令牌端点发起刷新请求：

- grant_type
  必需的。值必须设置为“refresh_token”。
- refresh_token
  必需的。颁发给客户端的刷新令牌。
- scope
  可选的。如[3.3](#3.3)节所述的访问请求的范围。请求的范围不能包含任何不是由资源所有者原始许可的范围，若省略，被视为与资源所有者原始许可的范围相同。
  
因为刷新令牌通常是用于请求额外的访问令牌的持久凭证，刷新令牌绑定到被它被颁发给的客户端。如果客户端类型是机密的或客户端被颁发了客户端凭据（或选定的其他身份验证要求），客户端必须如[3.2.1](../Section03/3.2.1.md)节所述与授权服务器进行身份验证。

例如，客户端使用传输层安全发起如下HTTP请求（额外的换行仅用于显示目的）：

```text
POST /token HTTP/1.1
Host: server.example.com
Authorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW
Content-Type: application/x-www-form-urlencoded
grant_type=refresh_token&refresh_token=tGzv3JOkF0XG5Qx2TlKWIA
```

授权服务器必须：

- 要求机密客户端或任何被颁发了客户端凭据（或有其他身份验证要求）的客户端进行客户端身份验证，
- 若包括了客户端身份验证，验证客户端身份并确保刷新令牌是被颁发给进行身份验证的客户端的，并
- 验证刷新令牌。

如果有效且被授权，授权服务器如[5.1](#5.1)节所述颁发访问令牌。如果请求因验证失败或无效，授权服务器[5.2](../Section05/5.2.md)节所述返回错误响应。

授权服务器可以颁发新的刷新令牌，在这种情况下，客户端必须放弃旧的刷新令牌，替换为新的刷新令牌。在向客户端颁发新的刷新令牌后授权服务器可以撤销旧的刷新令牌。若颁发了新的刷新令牌，刷新令牌的范围必须与客户端包含在请求中的刷新令牌的范围相同。

## 7 访问受保护资源

通过向资源服务器出示访问令牌，客户端访问受保护资源。资源服务器必须验证访问令牌，并确保它没有过期且其范围涵盖了请求的资源。资源服务器用于验证访问令牌的方法（以及任何错误响应）超出了本规范的范围，但一般包括资源服务器和授权服务器之间的互动或协调。

客户端使用访问令牌与资源服务器进行证认的方法依赖于授权服务器颁发的访问令牌的类型。通常，它涉及到使用具有所采用的访问令牌类型的规范定义的身份验证方案(如[RFC6750][RFC6750])的HTTP“Authorization”的请求标头字段[RFC2617][RFC2617]。

[RFC2617]: http://tools.ietf.org/html/rfc2617 "HTTP Authentication: Basic and Digest Access Authentication"
[RFC6750]: http://tools.ietf.org/html/rfc6750 "The OAuth 2.0 Authorization Framework: Bearer Token Usage"

### 7.1 访问令牌类型

### 7.2 错误响应

## 8 可扩展性

### 8.1 定义访问令牌类型

### 8.2 定义新的端点参数

### 8.3 定义新的授权许可类型

### 8.4 定义新的授权端点响应类型

### 8.5 定义其他错误代码

## 9 本机应用程序

本机应用程序是安装和执行在资源所有者使用的设备上的客户端（例如，桌面程序，本机移动应用）。本机应用程序需要关于安全、平台能力和整体最终用户体验的特别注意事项。

授权端点需要在客户端和资源所有者用户代理之间进行交互。本机应用程序可以调用外部的用户代理，或在应用程序中嵌入用户代理。例如：

- 外部用户代理-本机应用程序可以捕获来自授权服务器的响应。它可以使用带有操作系统已注册方案的重定向URI调用客户端作为处理程序，手动复制粘贴凭据，运行本地Web服务器，安装用户代理扩展，或者通过提供重定向URI来指定客户端控制下的服务器托管资源，反过来使响应对本机应用程序可用。
- 嵌入式用户代理-通过监视资源加载过程中发生的状态变化或者访问用户代理的cookies存储，本机应用程序直接与嵌入式用户代理通信，获得响应。
当在外部或嵌入式用户代理中选择时，开发者应该考虑如下：
- 外部用户代理可能会提高完成率，因为资源所有者可能已经有了与授权服务器的活动会话，避免了重新进行身份验证的需要。它提供了熟悉的最终用户体验和功能。资源所有者可能也依赖于用户代理特性或扩展帮助他进行身份验证（例如密码管理器、两步设备读取器）
- 嵌入式用户代理可能会提供更好的可用性，因为它避免了切换上下文和打开新窗口的需要。
- 嵌入式用户代理构成了安全挑战，因为资源所有者在一个未识别的窗口中进行身份验证，无法获得在大多数外部用户代理中的可视的保护。嵌入式用户代理教育用户信任未标识身份验证请求（使钓鱼攻击更易于实施）。
当在隐式许可类型和授权码许可类型中选择时，下列应该被考虑：
- 使用授权码许可类型的本机应用程序应该这么做而不需使用用户凭据，因为本机应用程序无力保持客户端凭据的机密性。
- 当使用隐式许可类型流程时，刷新令牌不会返回，这就要求一旦访问令牌过期就要重复授权过程。

## 10 安全性考虑

作为一个灵活的可扩展的框架，OAuth的安全性考量依赖于许多因素。 以下小节提为实现者提供了聚焦在[2.1](#2.1)节所述的三种客户端配置上的安全指南：**Web应用**、**基于用户代理的应用**和**本地应用程序**。

全面的OAuth安全模型和分析以及该协议设计的背景在[OAuth-THREATMODE]中提供。

### 10.1 客户端身份验证

### 10.2 客户端仿冒

### 10.3 访问令牌

### 10.4 刷新令牌

### 10.5 授权码

### 10.6 授权码重定向URI操纵

### 10.7 资源拥有者密码凭据

### 10.8 请求机密性

### 10.9 确保端点真实性

### 10.10 凭据猜测攻击

### 10.11 钓鱼攻击

### 10.12 跨站请求伪造

### 10.13 点击劫持

### 10.14 代码注入和输入验证

### 10.15 自由重定向

### 10.16 隐式流程中滥用访问令牌假冒资源所有者

## 11 IANA考量

### 11.1 OAuth访问令牌类型注册表

#### 11.1.1 注册模板 }

### 11.2 OAuth参数注册表

#### 11.2.1 注册模板 }

#### 11.2.2 初始注册表内容 }

### 11.3 OAuth授权端点响应类型注册表

#### 11.3.1 注册模板 }

#### 11.3.2 初始注册表内容 }

### 11.4 OAuth扩展错误注册表

#### 11.4.1 注册模板 }

## 12 参考文献

### 12.1 规范性文献

### 12.2 参考性文献

## 附录A. 增强巴科斯-诺尔范式（ABNF）语法

本节提供了本文档中定义的元素按[RFC5234][RFC5234]记法的增强巴克斯诺尔范式（ABNF）的语法描述。下列ABNF用Unicode代码要点[W3C.REC-XML-20081126]的术语定义；这些字符通常以UTF-8编码。元素按首次定义的顺序排列。

一些定义遵循使用来自[RFC3986][RFC3986]“URI引用”的定义。

一些定义遵循使用这些通用的定义：

```text
    VSCHAR     = %x20-7E
    NQCHAR     = %x21 / %x23-5B / %x5D-7E
    NQSCHAR    = %x20-21 / %x23-5B / %x5D-7E
    UNICODECHARNOCRLF = %x09 /%x20-7E / %x80-D7FF / %xE000-FFFD / %x10000-10FFFF
```

（UNICODECHARNOCRLF定义基于[W3C.REC-XML-20081126]2.2节中定义的字符，但忽略了回车和换行字符。）

[RFC5234]:http://tools.ietf.org/html/rfc5234 "Augmented BNF for Syntax Specifications: ABNF"
[RFC3986]:http://tools.ietf.org/html/rfc3986 "Uniform Resource Identifier (URI): Generic Syntax"

### A.1 “client_id”语法

### A.2 “client_secret”语法

### A.3 “response_type”语法

### A.4 “scope”语法

### A.5 “state”语法

### A.6 “redirect_uri”语法

### A.7 “error”语法

### A.8 “error_description”语法

### A.9 “error_uri”语法

### A.10 “grant_type”语法

### A.11 “code”语法

### A.12 “access_token”语法

### A.13 “token_type”语法

### A.14 “expires_in”语法

### A.15 “username”语法

### A.16 “password”语法

### A.17 “refresh_token”语法

### A.18 端点参数语法

## 附录B. 使用application/x-www-form-urlencoded媒体类型

## 附录C. 致谢

## 勘误

### 3446

勘误编号：3446

状态：已核实

类型：编辑

报告者：Nov Matake

报告日期：2013-01-07

审核者：Stephen Farrell

审核日期：2013-03-16

第1节：

－ 资源所有者不能撤销某个第三方的访问权限而不影响其它第三方，并且必须更改第三方的密码才能做到。

应该是：

－ 资源所有者不能撤销某个第三方的访问权限而不影响其它第三方，并且必须更改他们的密码才能做到。

备注：

文本原来是“他们的”但是在最后的草稿和RFC之间改成了“第三方的”。然而，“他们的”意思是“资源所有者的”，而不是“第三方的”。

### 3500

勘误编号：3500

状态：已核实

类型：编辑

报告者：John Field

报告日期：2013-02-26

审核者：Stephen Farrell

审核日期：2013-03-16

第[4.1](#4-1-授权码许可)节：

- （E）授权服务器对客户端进行身份验证，验证授权代码，并确保接收的重定向URI与在步骤（C）中用于重定向客户端的URI相匹配。如果通过，授权服务器响应返回访问令牌与可选的刷新令牌。
应该是：

- （E）授权服务器对客户端进行身份验证，验证授权代码，并确保接收的重定向URI与在步骤（C）中用于重定向（资源所有者的用户代理）到客户端的URI相匹配。如果通过，授权服务器响应返回访问令牌与可选的刷新令牌。

**备注**：

问题中的URI是用于重定向资源所有者的用户代理回到客户端传送代码的URI。（E）步骤中原文好像说该URI用于重定向客户端，但是我认为这是对“客户端”这个词的不明确／不准确的使用。OAuth客户端不会使用URI被重定向，资源所有者的用户代理会被重定向到客户端。

插入的“（资源所有者的用户代理）”会更准确但是可能会太冗长了。我觉得，至少，我们必须说“……该URI用于在步骤（C）中重定向到客户端。”

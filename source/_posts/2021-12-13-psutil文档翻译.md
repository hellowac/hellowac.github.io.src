---
title: psutil文档翻译
date: 2021-12-13 15:52:58
tags:
  - python
  - psutil
  - 翻译
  - 文档
categories:
  - 后端
  - 文档翻译
---

英文原文: <https://psutil.readthedocs.io/en/latest/#>

## psutil documentation

### 快速链接 - [原文](https://psutil.readthedocs.io/en/latest/#quick-links)

* [Home page](https://github.com/giampaolo/psutil)
* [Install](https://github.com/giampaolo/psutil/blob/master/INSTALL.rst)
* [Forum](http://groups.google.com/group/psutil/topics)
* [Download](https://pypi.org/project/psutil/#files)
* [Blog](https://gmpy.dev/tags/psutil)
* [Contributing](https://github.com/giampaolo/psutil/blob/master/CONTRIBUTING.md)
* [Development guide](https://github.com/giampaolo/psutil/blob/master/docs/DEVGUIDE.rst)
* [What’s new](https://github.com/giampaolo/psutil/blob/master/HISTORY.rst)

### 关于 (About) - [原文](https://psutil.readthedocs.io/en/latest/#about)

psutil (python system and process utilities) is a cross-platform library for retrieving information on running **processes** and **system utilization** (CPU, memory, disks, network, sensors) in **Python**. It is useful mainly for **system monitoring**, **profiling**, **limiting process resources** and the **management of running processes**. It implements many functionalities offered by UNIX command line tools such as: `ps`, `top`, `lsof`, `netstat`, `ifconfig`, `who`, `df`, `kill`, `free`, `nice`, `ionice`, `iostat`, `iotop`, `uptime`, `pidof`, `tty`, `taskset`, `pmap`. psutil 目前支持下面这些平台:

* **Linux**
* **Windows**
* **macOS**
* **FreeBSD**, **OpenBSD**, **NetBSD**
* **Sun Solaris**
* **AIX**

支持的Python版本是 **2.6**, **2.7** 和 **3.4+**. [PyPy](http://pypy.org/) 也可以工作.

你正在读的psutil文档是作为单个HTML页面分发(发布)的。

### 基金 (Funding)

While psutil is free software and will always be, the project would benefit immensely from some funding. Keeping up with bug reports and maintenance has become hardly sustainable for me alone in terms of time. If you’re a company that’s making significant use of psutil you can consider becoming a sponsor via [GitHub](https://github.com/sponsors/giampaolo), [Open Collective](https://opencollective.com/psutil) or [PayPal](https://www.paypal.com/cgi-bin/webscr?cmd=_s-xclick&hosted_button_id=A9ZS7PKKRM3S8) and have your logo displayed in here and psutil [doc](https://psutil.readthedocs.io/).

#### 赞助 (Sponsors)

<div>
    <a href="https://tidelift.com/subscription/pkg/pypi-psutil?utm_source=pypi-psutil&amp;utm_medium=referral&amp;utm_campaign=readme">
        <img width="185" src="https://github.com/giampaolo/psutil/raw/master/docs/_static/tidelift-logo.svg?s=185&v=4">
    </a>
    &nbsp;&nbsp;
    <a href="https://sansec.io/">
        <img src="https://sansec.io/assets/images/logo.svg">
    </a>
</div>

添加你的[logo](https://github.com/sponsors/giampaolo)

#### 支持 (Supporters)

[![dbwiddis](https://avatars1.githubusercontent.com/u/9291703?s=44&v=4)](https://github.com/dbwiddis)
[![aristocratos](https://avatars3.githubusercontent.com/u/59659483?s=44&v=4)](https://github.com/aristocratos)
[![cybersecgeek](https://avatars.githubusercontent.com/u/12847926?s=44&v=4)](https://github.com/cybersecgeek)
[![scoutapm sponsorships](https://avatars.githubusercontent.com/u/71095532?s=44&v=4)](https://github.com/scoutapm-sponsorships)
[![chenyoo hao](https://images.opencollective.com/chenyoo-hao/avatar/40.png?s=44&v=4)](https://opencollective.com/chenyoo-hao)
[![alexey vazhnov](https://images.opencollective.com/alexey-vazhnov/daed334/avatar/40.png?s=44&v=4)](https://opencollective.com/alexey-vazhnov)

添加你的[头像](https://github.com/sponsors/giampaolo)

### 安装 (Install) - [原文](https://psutil.readthedocs.io/en/latest/#install-1)

在 Linux, Windows, macOS:

```shell
pip install psutil
```

对于其他平台，请参阅更详细的[安装说明](https://github.com/giampaolo/psutil/blob/master/INSTALL.rst)

## 系统相关函数 (System related functions) - [原文](https://psutil.readthedocs.io/en/latest/#system-related-functions)

### CPU (cpu) - [原文](https://psutil.readthedocs.io/en/latest/#cpu)

**psutil.cpu_times(percpu=False)** - [原文](https://psutil.readthedocs.io/en/latest/#psutil.cpu_times)

:::details 展现详细
Return system CPU times as a named tuple. Every attribute represents the seconds the CPU has spent in the given mode. The attributes availability varies depending on the platform:

* **user**: time spent by normal processes executing in user mode; on Linux this also includes guest time
* **system**: time spent by processes executing in kernel mode
* **idle**: time spent doing nothing

Platform-specific fields:

* **nice** (UNIX): time spent by niced (prioritized) processes executing in user mode; on Linux this also includes guest_nice time
* **iowait** (Linux): time spent waiting for I/O to complete. This is not accounted in idle time counter.
* **irq** (Linux, BSD): time spent for servicing hardware interrupts
* **softirq** (Linux): time spent for servicing software interrupts
* **steal** (Linux 2.6.11+): time spent by other operating systems running in a virtualized environment
* **guest** (Linux 2.6.24+): time spent running a virtual CPU for guest operating systems under the control of the Linux kernel
* **guest_nice** (Linux 3.2.0+): time spent running a niced guest (virtual CPU for guest operating systems under the control of the Linux kernel)
* **interrupt** (Windows): time spent for servicing hardware interrupts ( similar to “irq” on UNIX)
* **dpc** (Windows): time spent servicing deferred procedure calls (DPCs); DPCs are interrupts that run at a lower priority than standard interrupts.

When percpu is True return a list of named tuples for each logical CPU on the system. First element of the list refers to first CPU, second element to second CPU and so on. The order of the list is consistent across calls. Example output on Linux:

```python
>>> import psutil
>>> psutil.cpu_times()
scputimes(user=17411.7, nice=77.99, system=3797.02, idle=51266.57, iowait=732.58, irq=0.01, softirq=142.43, steal=0.0, guest=0.0, guest_nice=0.0)
```

Changed in version 4.1.0: added interrupt and dpc fields on Windows.

:::

:::warning
CPU times are always supposed to increase over time, or at least remain the same, and that’s because time cannot go backwards. Surprisingly sometimes this might not be the case (at least on Windows and Linux), see [#1210](https://github.com/giampaolo/psutil/issues/1210#issuecomment-363046156).
:::

**psutil.cpu_percent(interval=None, percpu=False)** - [原文](https://psutil.readthedocs.io/en/latest/#psutil.cpu_percent)

:::details 展现详细
Return a float representing the current system-wide CPU utilization as a percentage. When interval is > 0.0 compares system CPU times elapsed before and after the interval (blocking). When interval is 0.0 or None compares system CPU times elapsed since last call or module import, returning immediately. That means the first time this is called it will return a meaningless 0.0 value which you are supposed to ignore. In this case it is recommended for accuracy that this function be called with at least 0.1 seconds between calls. When percpu is True returns a list of floats representing the utilization as a percentage for each CPU. First element of the list refers to first CPU, second element to second CPU and so on. The order of the list is consistent across calls.

```python
>>> import psutil
>>> # blocking
>>> psutil.cpu_percent(interval=1)
2.0
>>> # non-blocking (percentage since last call)
>>> psutil.cpu_percent(interval=None)
2.9
>>> # blocking, per-cpu
>>> psutil.cpu_percent(interval=1, percpu=True)
[2.0, 1.0]
>>>
```
:::

:::warning
the first time this function is called with interval = 0.0 or None it will return a meaningless 0.0 value which you are supposed to ignore.
:::

**psutil.cpu_times_percent(interval=None, percpu=False)** - [原文](https://psutil.readthedocs.io/en/latest/#psutil.cpu_times_percent)

:::details 展现详细

Same as cpu_percent() but provides utilization percentages for each specific CPU time as is returned by psutil.cpu_times(percpu=True). interval and percpu arguments have the same meaning as in cpu_percent(). On Linux “guest” and “guest_nice” percentages are not accounted in “user” and “user_nice” percentages.

:::

:::warning
the first time this function is called with interval = 0.0 or None it will return a meaningless 0.0 value which you are supposed to ignore.
:::

:::tip
Changed in version 4.1.0: two new interrupt and dpc fields are returned on Windows.
:::

**psutil.cpu_count(logical=True)** - [原文](https://psutil.readthedocs.io/en/latest/#psutil.cpu_count)

:::details 展现详细
Return the number of logical CPUs in the system (same as os.cpu_count in Python 3.4) or None if undetermined. “logical CPUs” means the number of physical cores multiplied by the number of threads that can run on each core (this is known as Hyper Threading). If logical is False return the number of physical cores only, or None if undetermined. On OpenBSD and NetBSD psutil.cpu_count(logical=False) always return None. Example on a system having 2 cores + Hyper Threading:

```python
>>> import psutil
>>> psutil.cpu_count()
4
>>> psutil.cpu_count(logical=False)
2
```

Note that psutil.cpu_count() may not necessarily be equivalent to the actual number of CPUs the current process can use. That can vary in case process CPU affinity has been changed, Linux cgroups are being used or (in case of Windows) on systems using processor groups or having more than 64 CPUs. The number of usable CPUs can be obtained with:

```python
>>> len(psutil.Process().cpu_affinity())
1
psutil.cpu_stats()
```
:::

**psutil.cpu_stats()** - [原文](https://psutil.readthedocs.io/en/latest/#psutil.cpu_stats)

:::details 展现详细
Return various CPU statistics as a named tuple:

* **ctx_switches**: number of context switches (voluntary + involuntary) since boot.
* **interrupts**: number of interrupts since boot.
* **soft_interrupts**: number of software interrupts since boot. Always set to 0 on Windows and SunOS.
* **syscalls**: number of system calls since boot. Always set to 0 on Linux.

Example (Linux):

```python
>>> import psutil
>>> psutil.cpu_stats()
scpustats(ctx_switches=20455687, interrupts=6598984, soft_interrupts=2134212, syscalls=0)
```
:::

:::tip
New in version 4.1.0.
:::

**psutil.cpu_freq(percpu=False)** - [原文](https://psutil.readthedocs.io/en/latest/#psutil.cpu_freq)

:::details 展现详细
Return CPU frequency as a named tuple including current, min and max frequencies expressed in Mhz. On Linux current frequency reports the real-time value, on all other platforms it represents the nominal “fixed” value. If percpu is True and the system supports per-cpu frequency retrieval (Linux only) a list of frequencies is returned for each CPU, if not, a list with a single element is returned. If min and max cannot be determined they are set to 0.

Example (Linux):

```python
>>> import psutil
>>> psutil.cpu_freq()
scpufreq(current=931.42925, min=800.0, max=3500.0)
>>> psutil.cpu_freq(percpu=True)
[scpufreq(current=2394.945, min=800.0, max=3500.0),
 scpufreq(current=2236.812, min=800.0, max=3500.0),
 scpufreq(current=1703.609, min=800.0, max=3500.0),
 scpufreq(current=1754.289, min=800.0, max=3500.0)]
```
:::

:::tip
可用平台: Linux, macOS, Windows, FreeBSD

5.1.0 版本中新增。

5.5.1 版本中更新：添加了 FreeBSD 支持。
:::

**psutil.getloadavg()** - [原文](https://psutil.readthedocs.io/en/latest/#psutil.getloadavg)

:::details 展现详细
Return the average system load over the last 1, 5 and 15 minutes as a tuple. The “load” represents the processes which are in a runnable state, either using the CPU or waiting to use the CPU (e.g. waiting for disk I/O). On UNIX systems this relies on os.getloadavg. On Windows this is emulated by using a Windows API that spawns a thread which keeps running in background and updates results every 5 seconds, mimicking the UNIX behavior. Thus, on Windows, the first time this is called and for the next 5 seconds it will return a meaningless (0.0, 0.0, 0.0) tuple. The numbers returned only make sense if related to the number of CPU cores installed on the system. So, for instance, a value of 3.14 on a system with 10 logical CPUs means that the system load was 31.4% percent over the last N minutes.

```python
>>> import psutil
>>> psutil.getloadavg()
(3.14, 3.89, 4.67)
>>> psutil.cpu_count()
10
>>> # percentage representation
>>> [x / psutil.cpu_count() * 100 for x in psutil.getloadavg()]
[31.4, 38.9, 46.7]

```
:::

:::tip
可用平台: Unix, Windows

5.6.2 版本中新增。

:::

### 内存 (Memory) - [原文](https://psutil.readthedocs.io/en/latest/#memory)

**psutil.virtual_memory()** - 原文

**psutil.swap_memory()** - 原文

### 磁盘 (Disks) - [原文](https://psutil.readthedocs.io/en/latest/#disks)

**psutil.disk_partitions(all=False)** - 原文

**psutil.disk_usage(path)** - 原文

**psutil.disk_io_counters(perdisk=False, nowrap=True)** - 原文

### 网络 (Network) - [原文](https://psutil.readthedocs.io/en/latest/#network)

**psutil.net_io_counters(pernic=False, nowrap=True)** - 原文

**psutil.net_connections(kind='inet')** - 原文

**psutil.net_if_addrs()** - 原文

**psutil.net_if_stats()** - 原文

### 传感器 (Sensors) - 原文

**psutil.sensors_temperatures(fahrenheit=False)** - 原文

**psutil.sensors_fans()** - 原文

**psutil.sensors_battery()** - 原文

### 其他系统信息(Other system info) - [原文](https://psutil.readthedocs.io/en/latest/#other-system-info)

**psutil.boot_time()** - 原文

**psutil.users()** - 原文

## 进程相关 (Processes) - [原文](https://psutil.readthedocs.io/en/latest/#functions)

### 函数 (Functions) - [原文](https://psutil.readthedocs.io/en/latest/#functions)

**psutil.pids()** - 原文

**psutil.process_iter(attrs=None, ad_value=None)** - 原文

**psutil.pid_exists(pid)** - 原文

**psutil.wait_procs(procs, timeout=None, callback=None)** - 原文

### 异常 (Exceptions) - [原文](https://psutil.readthedocs.io/en/latest/#exceptions)

`class` **psutil.Error** - 原文

`class` **psutil.NoSuchProcess(pid, name=None, msg=None)** - 原文

`class` **psutil.ZombieProcess(pid, name=None, ppid=None, msg=None)** - 原文

`class` **psutil.AccessDenied(pid=None, name=None, msg=None)** - 原文

`class` **psutil.TimeoutExpired(seconds, pid=None, name=None, msg=None)** - 原文

### 进程类 (Process class) - [原文](https://psutil.readthedocs.io/en/latest/#process-class)

`class` **psutil.Process(pid=None)** - [原文](https://psutil.readthedocs.io/en/latest/#psutil.Process)

* oneshot() - 原文
* pid - 原文
* ppid() - 原文
* name() - 原文
* exe() - 原文
* cmdline() - 原文
* environ() - 原文
* create_time() - 原文
* as_dict(attrs=None, ad_value=None) - 原文
* parent() - 原文
* parents() - 原文
* status() - 原文
* cwd() - 原文
* username() - 原文
* uids() - 原文
* gids() - 原文
* terminal() - 原文
* nice(value=None) - 原文
* ionice(ioclass=None, value=None) - 原文
* rlimit(resource, limits=None) - 原文
* io_counters() - 原文
* num_ctx_switches() - 原文
* num_fds() - 原文
* num_handles() - 原文
* num_threads() - 原文
* threads() - 原文
* cpu_times() - 原文
* cpu_percent(interval=None) - 原文
* cpu_affinity(cpus=None) - 原文
* cpu_num() - 原文
* memory_info() - 原文
* memory_info_ex() - 原文
* memory_full_info() - 原文
* memory_percent(memtype="rss") - 原文
* memory_maps(grouped=True) - 原文
* children(recursive=False) - 原文
* open_files() - 原文
* connections(kind="inet") - 原文
* is_running() - 原文
* send_signal(signal) - 原文
* suspend() - 原文
* resume() - 原文
* terminate() - 原文
* kill() - 原文
* wait(timeout=None) - [原文](https://psutil.readthedocs.io/en/latest/#psutil.Process.wait)
  Wait for a process PID to terminate. The details about the return value differ on UNIX and Windows.
  On UNIX: if the process terminated normally, the return value is a positive integer >= 0 indicating the exit code. If the process was terminated by a signal return the negated value of the signal which caused the termination (e.g. -SIGTERM). If PID is not a children of os.getpid (current process) just wait until the process disappears and return None. If PID does not exist return None immediately.
  On Windows: always return the exit code, which is a positive integer as returned by GetExitCodeProcess.
  timeout is expressed in seconds. If specified and the process is still alive raise TimeoutExpired exception. timeout=0 can be used in non-blocking apps: it will either return immediately or raise TimeoutExpired.
  The return value is cached. To wait for multiple processes use psutil.wait_procs().
  ```python
  >>> import psutil
  >>> p = psutil.Process(9891)
  >>> p.terminate()
  >>> p.wait()
  <Negsignal.SIGTERM: -15>
  ```
  Changed in version 5.7.1: return value is cached (instead of returning None).
  Changed in version 5.7.1: on POSIX, in case of negative signal, return it as a human readable enum.
* `class` **psutil.Popen(\*args, \*\*kwargs)** - [原文](https://psutil.readthedocs.io/en/latest/#psutil.Popen)
  Same as subprocess.Popen but in addition it provides all psutil.Process methods in a single class. For the following methods which are common to both classes, psutil implementation takes precedence: send_signal(), terminate(), kill(). This is done in order to avoid killing another process in case its PID has been reused, fixing BPO-6973.
  ```python
  >>> import psutil
  >>> from subprocess import PIPE
  >>>
  >>> p = psutil.Popen(["/usr/bin/python", "-c", "print('hello')"], stdout=PIPE)
  >>> p.name()
  'python'
  >>> p.username()
  'giampaolo'
  >>> p.communicate()
  ('hello\n', None)
  >>> p.wait(timeout=2)
  0
  >>>
  ```
  版本 4.4.0 中改变: 新增支持上下文管理

## Windows平台 服务 (Windows services) - [原文](https://psutil.readthedocs.io/en/latest/#windows-services)

**psutil.win_service_iter()** - [原文](https://psutil.readthedocs.io/en/latest/#psutil.win_service_iter)

Return an iterator yielding a WindowsService class instance for all Windows services installed.

版本 4.2.0 中新增.

可用平台: Windows

**psutil.win_service_get(name)** - [原文](https://psutil.readthedocs.io/en/latest/#psutil.win_service_get)

Get a Windows service by name, returning a WindowsService instance. Raise psutil.NoSuchProcess if no service with such name exists.

版本 4.2.0 中新增.

可用平台: Windows

`class` **psutil.WindowsService** - [原文](https://psutil.readthedocs.io/en/latest/#psutil.WindowsService)

Represents a Windows service with the given name. This class is returned by win_service_iter() and win_service_get() functions and it is not supposed to be instantiated directly.

* name() - [原文](https://psutil.readthedocs.io/en/latest/#psutil.WindowsService.name)
  The service name. This string is how a service is referenced and can be passed to win_service_get() to get a new WindowsService instance.
* display_name() - [原文](https://psutil.readthedocs.io/en/latest/#psutil.WindowsService.display_name)
  The service display name. The value is cached when this class is instantiated.
* binpath() - [原文](https://psutil.readthedocs.io/en/latest/#psutil.WindowsService.binpath)
  The fully qualified path to the service binary/exe file as a string, including command line arguments.
* username() - [原文](https://psutil.readthedocs.io/en/latest/#psutil.WindowsService.username)
  The name of the user that owns this service.
* start_type() - [原文](https://psutil.readthedocs.io/en/latest/#psutil.WindowsService.start_type)
  A string which can either be “automatic”, “manual” or “disabled”.
* pid() - [原文](https://psutil.readthedocs.io/en/latest/#psutil.WindowsService.pid)
  The process PID, if any, else None. This can be passed to Process class to control the service’s process.
* status() - [原文](https://psutil.readthedocs.io/en/latest/#psutil.WindowsService.status)
  Service status as a string, which may be either “running”, “paused”, “start_pending”, “pause_pending”, “continue_pending”, “stop_pending” or “stopped”.
* description() - [原文](https://psutil.readthedocs.io/en/latest/#psutil.WindowsService.description)
  Service long description.
* as_dict()
  Utility method retrieving all the information above as a dictionary. - [原文](https://psutil.readthedocs.io/en/latest/#psutil.WindowsService.as_dict)

版本 4.2.0 中新增.
可用平台: Windows

:::details 样例代码

```python
>>> import psutil
>>> list(psutil.win_service_iter())
[<WindowsService(name='AeLookupSvc', display_name='Application Experience') at 38850096>,
 <WindowsService(name='ALG', display_name='Application Layer Gateway Service') at 38850128>,
 <WindowsService(name='APNMCP', display_name='Ask Update Service') at 38850160>,
 <WindowsService(name='AppIDSvc', display_name='Application Identity') at 38850192>,
 ...]
>>> s = psutil.win_service_get('alg')
>>> s.as_dict()
{'binpath': 'C:\\Windows\\System32\\alg.exe',
 'description': 'Provides support for 3rd party protocol plug-ins for Internet Connection Sharing',
 'display_name': 'Application Layer Gateway Service',
 'name': 'alg',
 'pid': None,
 'start_type': 'manual',
 'status': 'stopped',
 'username': 'NT AUTHORITY\\LocalService'}
```
:::

## 常量 (Constants) - [原文](https://psutil.readthedocs.io/en/latest/#constants)

### 操作系统常量 - [原文](https://psutil.readthedocs.io/en/latest/#operating-system-constants)

* psutil.**POSIX**
* psutil.**LINUX**
* psutil.**WINDOWS**
* psutil.**MACOS**
* psutil.**FREEBSD**
* psutil.**NETBSD**
* psutil.**OPENBSD**
* psutil.**BSD**
* psutil.**SUNOS**
* psutil.**AIX**
  `bool` 常量, 该常量定义了你属于什么平台. 例如: 如果在Windows平台, **WINDOWS** 常量将会为 `True`, 其他平台将会为 `False`.
  New in 版本 4.0.0. 中新增
  版本 5.4.0 中改变过: 新增 AIX
* psutil.**OSX**
  **MACOS** 的别名.
  **注意**: 版本 5.4.7 中已弃用; 使用 **MACOS** 替换.
  
* psutil.**PROCFS_PATH**
  The path of the /proc filesystem on Linux, Solaris and AIX (defaults to "/proc"). You may want to re-set this constant right after importing psutil in case your /proc filesystem is mounted elsewhere or if you want to retrieve information about Linux containers such as Docker, Heroku or LXC (see here for more info). It must be noted that this trick works only for APIs which rely on /proc filesystem (e.g. memory APIs and most Process class methods).
  Availability: Linux, Solaris, AIX
  New in version 3.2.3.
  Changed in version 3.4.2: also available on Solaris.
  Changed in version 5.4.0: also available on AIX.

### 进程状态常量 (Process status constants) - [原文](https://psutil.readthedocs.io/en/latest/#process-status-constants)

* psutil.**STATUS_RUNNING**
* psutil.**STATUS_SLEEPING**
* psutil.**STATUS_DISK_SLEEP**
* psutil.**STATUS_STOPPED**
* psutil.**STATUS_TRACING_STOP**
* psutil.**STATUS_ZOMBIE**
* psutil.**STATUS_DEAD**
* psutil.**STATUS_WAKE_KILL**
* psutil.**STATUS_WAKING**
* psutil.**STATUS_PARKED)**(_Linux_)
* psutil.**STATUS_IDLE)**(_Linux_, _macOS_, _FreeBSD_)
* psutil.**STATUS_LOCKED)**(_FreeBSD_)
* psutil.**STATUS_WAITING)**(_FreeBSD_)
* psutil.**STATUS_SUSPENDED)**(_NetBSD_
  Represent a process status. Returned by psutil.Process.status().
  New in version 3.4.1: STATUS_SUSPENDED (NetBSD)
  New in version 5.4.7: STATUS_PARKED (Linux)

### 进程优先级常量(Process priority constants) - [原文](https://psutil.readthedocs.io/en/latest/#process-priority-constants)

* psutil.**REALTIME_PRIORITY_CLASS**
* psutil.**HIGH_PRIORITY_CLASS**
* psutil.**ABOVE_NORMAL_PRIORITY_CLASS**
* psutil.**ABOVE_NORMAL_PRIORITY_CLASS**
* psutil.**NORMAL_PRIORITY_CLASS**
* psutil.**IDLE_PRIORITY_CLASS**
* psutil.**BELOW_NORMAL_PRIORITY_CLASS**
  Represent the priority of a process on Windows (see SetPriorityClass). They can be used in conjunction with psutil.Process.nice() to get or set process priority.
  Availability: Windows
* psutil.**IOPRIO_CLASS_NONE**
* psutil.**IOPRIO_CLASS_RT**
* psutil.**IOPRIO_CLASS_BE**
* psutil.**IOPRIO_CLASS_IDLE**
  A set of integers representing the I/O priority of a process on Linux. They can be used in conjunction with psutil.Process.ionice() to get or set process I/O priority. IOPRIO_CLASS_NONE and IOPRIO_CLASS_BE (best effort) is the default for any process that hasn’t set a specific I/O priority. IOPRIO_CLASS_RT (real time) means the process is given first access to the disk, regardless of what else is going on in the system. IOPRIO_CLASS_IDLE means the process will get I/O time when no-one else needs the disk. For further information refer to manuals of ionice command line utility or ioprio_get system call.
  Availability: Linux
* psutil.**IOPRIO_VERYLOW**
* psutil.**IOPRIO_LOW**
* psutil.**IOPRIO_NORMAL**
* psutil.**IOPRIO_HIGH**
  A set of integers representing the I/O priority of a process on Windows. They can be used in conjunction with psutil.Process.ionice() to get or set process I/O priority.
  Availability: Windows
  New in version 5.6.2.

### 进程资源常量 (Process resources constants) - [原文](https://psutil.readthedocs.io/en/latest/#process-resources-constants)

* **Linux** / **FreeBSD**:
  * psutil.**RLIM_INFINITY**
  * psutil.**RLIMIT_AS**
  * psutil.**RLIMIT_CORE**
  * psutil.**RLIMIT_CPU**
  * psutil.**RLIMIT_DATA**
  * psutil.**RLIMIT_FSIZE**
  * psutil.**RLIMIT_MEMLOCK**
  * psutil.**RLIMIT_NOFILE**
  * psutil.**RLIMIT_NPROC**
  * psutil.**RLIMIT_RSS**
  * psutil.**RLIMIT_STACK**
* Linux specific:
  * psutil.**RLIMIT_LOCKS**
  * psutil.**RLIMIT_MSGQUEUE**
  * psutil.**RLIMIT_NICE**
  * psutil.**RLIMIT_RTPRIO**
  * psutil.**RLIMIT_RTTIME**
  * psutil.**RLIMIT_SIGPENDING**
* FreeBSD specific:
  * psutil.**RLIMIT_SWAP**
  * psutil.**RLIMIT_SBSIZE**
  * psutil.**RLIMIT_NPTS**

Constants used for getting and setting process resource limits to be used in conjunction with psutil.Process.rlimit(). See resource.getrlimit for further information.

Availability: Linux, FreeBSD

Changed in version 5.7.3: added FreeBSD support, added RLIMIT_SWAP, RLIMIT_SBSIZE, RLIMIT_NPTS.

### 连接常量(Connections constants) - [原文](https://psutil.readthedocs.io/en/latest/#connections-constants)

* psutil.**CONN_ESTABLISHED**
* psutil.**CONN_SYN_SENT**
* psutil.**CONN_SYN_RECV**
* psutil.**CONN_FIN_WAIT1**
* psutil.**CONN_FIN_WAIT2**
* psutil.**CONN_TIME_WAIT**
* psutil.**CONN_CLOSE**
* psutil.**CONN_CLOSE_WAIT**
* psutil.**CONN_LAST_ACK**
* psutil.**CONN_LISTEN**
* psutil.**CONN_CLOSING**
* psutil.**CONN_NONE**
* psutil.**CONN_DELETE_TCB**(_Windows_)
* psutil.**CONN_IDLE**(_Solaris_)
* psutil.**CONN_BOUND**(_Solaris_)
  A set of strings representing the status of a TCP connection. Returned by psutil.Process.connections() and psutil.net_connections() (status field).

### 硬件常量(Hardware constants) - [原文](https://psutil.readthedocs.io/en/latest/#hardware-constants)

* AF_LINK
  Constant which identifies a MAC address associated with a network interface. To be used in conjunction with psutil.net_if_addrs().
  New in version 3.0.0.
* NIC_DUPLEX_FULL
* NIC_DUPLEX_HALF
* NIC_DUPLEX_UNKNOWN
  Constants which identifies whether a NIC (network interface card) has full or half mode speed. NIC_DUPLEX_FULL means the NIC is able to send and receive data (files) simultaneously, NIC_DUPLEX_FULL means the NIC can either send or receive data at a time. To be used in conjunction with psutil.net_if_stats().
  New in version 3.0.0.
* POWER_TIME_UNKNOWN
* POWER_TIME_UNLIMITED
  Whether the remaining time of the battery cannot be determined or is unlimited. May be assigned to psutil.sensors_battery()’s secsleft field.
  New in version 5.1.0.
* version_info
  A tuple to check psutil installed version. Example:
  ```python
  >>> import psutil
  >>> if psutil.version_info >= (4, 5):
  ...    pass
  ```

## 函数片段(Recipes) - [原文](https://psutil.readthedocs.io/en/latest/#recipes)

### 通过名称寻找进程(Find process by name) - [原文](https://psutil.readthedocs.io/en/latest/#find-process-by-name)

Check string against `Process.name()`:

```python
import psutil

def find_procs_by_name(name):
    "Return a list of processes matching 'name'."
    ls = []
    for p in psutil.process_iter(['name']):
        if p.info['name'] == name:
            ls.append(p)
    return ls
```

A bit more advanced, check string against Process.name(), Process.exe() and Process.cmdline():

```python
import os
import psutil

def find_procs_by_name(name):
    "Return a list of processes matching 'name'."
    ls = []
    for p in psutil.process_iter(["name", "exe", "cmdline"]):
        if name == p.info['name'] or \
                p.info['exe'] and os.path.basename(p.info['exe']) == name or \
                p.info['cmdline'] and p.info['cmdline'][0] == name:
            ls.append(p)
    return ls
```

### 终止进程树 (Kill process tree) - [原文](https://psutil.readthedocs.io/en/latest/#kill-process-tree)

```python
import os
import signal
import psutil

def kill_proc_tree(pid, sig=signal.SIGTERM, include_parent=True,
                   timeout=None, on_terminate=None):
    """Kill a process tree (including grandchildren) with signal
    "sig" and return a (gone, still_alive) tuple.
    "on_terminate", if specified, is a callback function which is
    called as soon as a child terminates.
    """
    assert pid != os.getpid(), "won't kill myself"
    parent = psutil.Process(pid)
    children = parent.children(recursive=True)
    if include_parent:
        children.append(parent)
    for p in children:
        try:
            p.send_signal(sig)
        except psutil.NoSuchProcess:
            pass
    gone, alive = psutil.wait_procs(children, timeout=timeout,
                                    callback=on_terminate)
    return (gone, alive)
```

### 过滤和排序进程 (Filtering and sorting processes) - [原文](https://psutil.readthedocs.io/en/latest/#filtering-and-sorting-processes)

这个代码样例合集将展示如果通过`process_iter()`函数去过滤和排序进程。开始:

```python
>>> import psutil
>>> from pprint import pprint as pp
```

当前用户拥有的进程:

```python
>>> import getpass
>>> pp([(p.pid, p.info['name']) for p in psutil.process_iter(['name', 'username']) if p.info['username'] == getpass.getuser()])
(16832, 'bash'),
(19772, 'ssh'),
(20492, 'python')]
```

正在运行的进程:

```python
>>> pp([(p.pid, p.info) for p in psutil.process_iter(['name', 'status']) if p.info['status'] == psutil.STATUS_RUNNING])
[(1150, {'name': 'Xorg', 'status': 'running'}),
 (1776, {'name': 'unity-panel-service', 'status': 'running'}),
 (20492, {'name': 'python', 'status': 'running'})]
```

使用log日志文件的进程:

```python
>>> for p in psutil.process_iter(['name', 'open_files']):
...      for file in p.info['open_files'] or []:
...          if file.path.endswith('.log'):
...               print("%-5s %-10s %s" % (p.pid, p.info['name'][:10], file.path))
...
1510  upstart    /home/giampaolo/.cache/upstart/unity-settings-daemon.log
2174  nautilus   /home/giampaolo/.local/share/gvfs-metadata/home-ce08efac.log
2650  chrome     /home/giampaolo/.config/google-chrome/Default/data_reduction_proxy_leveldb/000003.log
```

进程消耗超过500M的内存:

```python
>>> pp([(p.pid, p.info['name'], p.info['memory_info'].rss) for p in psutil.process_iter(['name', 'memory_info']) if p.info['memory_info'].rss > 500 * 1024 * 1024])
[(2650, 'chrome', 532324352),
 (3038, 'chrome', 1120088064),
 (21915, 'sublime_text', 615407616)]
```

Top 3 processes which consumed the most CPU time:

```python
>>> pp([(p.pid, p.info['name'], sum(p.info['cpu_times'])) for p in sorted(psutil.process_iter(['name', 'cpu_times']), key=lambda p: sum(p.info['cpu_times'][:2]))][-3:])
[(2721, 'chrome', 10219.73),
 (1150, 'Xorg', 11116.989999999998),
 (2650, 'chrome', 18451.97)]
```

### 字节转换 (Bytes conversion) - [原文](https://psutil.readthedocs.io/en/latest/#bytes-conversion)

```python
import psutil

def bytes2human(n):
    # http://code.activestate.com/recipes/578019
    # >>> bytes2human(10000)
    # '9.8K'
    # >>> bytes2human(100001221)
    # '95.4M'
    symbols = ('K', 'M', 'G', 'T', 'P', 'E', 'Z', 'Y')
    prefix = {}
    for i, s in enumerate(symbols):
        prefix[s] = 1 << (i + 1) * 10
    for s in reversed(symbols):
        if n >= prefix[s]:
            value = float(n) / prefix[s]
            return '%.1f%s' % (value, s)
    return "%sB" % n

total = psutil.disk_usage('/').total
print(total)
print(bytes2human(total))
```

…prints:

```python
100399730688
93.5G
```

## 常见问题 (FAQs) - [原文](https://psutil.readthedocs.io/en/latest/#faqs)

* Q: 为什么某些进程我会无权限?
* A: 当你查询其他用户拥有的进程时可能会发生这种情况，尤其是在 macOS (参考[问题 #883](https://github.com/giampaolo/psutil/issues/883)) 和 Windows 上。不幸的是，除了以更高的权限运行 Python 进程之外，您对此无能为力。 在 Unix 上，你可以以 root 身份运行 Python 进程或使用 SUID 位（ps 和 netstat 执行此操作）。 在 Windows 上，你可以将 Python 进程作为 NT AUTHORITY\SYSTEM 运行，或者将 Python 脚本安装为 Windows 服务（ProcessHacker 执行此操作）。
* Q: 支持在windows系统的MinGW上运行吗?
* A: 不支持, 你应该使用 Visual Studio (参阅 [开发指南](https://github.com/giampaolo/psutil/blob/master/docs/DEVGUIDE.rst)).

## 进行测试 (Running tests) - [原文](https://psutil.readthedocs.io/en/latest/#running-tests)

```python
python3 -m psutil.tests
```

### debug模式 (Debug mode) - [原文](https://psutil.readthedocs.io/en/latest/#debug-mode)

如果你想调试异常情况或报告一个漏洞，使用环境变量`PSUTIL_DEBUG`开启调试模式将会对你非常有用。在调试模式中，psutil会(或者不会)打印额外的信息到标准错误输出(stderr)。通常这些错误情况并不严重，因此常被忽略（防止崩溃）。在调试模式启动时单元测试是自动运行的。在Unix中：

```python
$ PSUTIL_DEBUG=1 python3 script.py
psutil-debug [psutil/_psutil_linux.c:150]> setmntent() failed (ignored)
```

在windows系统中:

```python
set PSUTIL_DEBUG=1 python.exe script.py
psutil-debug [psutil/arch/windows/process_info.c:90]> NtWow64ReadVirtualMemory64(pbi64.PebBaseAddress) -> 998 (Unknown error) (ignored)
```

## 安全 (Security) - [原文](https://psutil.readthedocs.io/en/latest/#security)

在报告安全漏洞时, 请使用 [Tidelift 安全联系人](https://tidelift.com/security). Tidelift 将协调修复和披露。

## 开发指南 (Development guide) - [原文](https://psutil.readthedocs.io/en/latest/#development-guide-1)

如果你想开发psutil，先看看[开发指南](https://github.com/giampaolo/psutil/blob/master/docs/DEVGUIDE.rst).

## 平台支持历史 (Platforms support history)  - [原文](https://psutil.readthedocs.io/en/latest/#platforms-support-history)

* psutil 5.8.1 (2021-10): MidnightBSD
* psutil 5.8.0 (2020-12): PyPy 2 on Windows
* psutil 5.7.1 (2020-07): Windows Nano
* psutil 5.7.0 (2020-02): drop Windows XP & Server 2003 support
* psutil 5.7.0 (2020-02): PyPy 3 on Windows
* psutil 5.4.0 (2017-11): AIX
* psutil 3.4.1 (2016-01): NetBSD
* psutil 3.3.0 (2015-11): OpenBSD
* psutil 1.0.0 (2013-07): Solaris
* psutil 0.1.1 (2009-03): FreeBSD
* psutil 0.1.0 (2009-01): Linux, Windows, macOS

支持的python版本是 `2.6`, `2.7`, `3.4+` 和 `PyPy3`.

## 时间线 (Timeline) - [原文](https://psutil.readthedocs.io/en/latest/#timeline)

* 2020-12-19: [5.8.0](https://pypi.org/project/psutil/5.8.0/#files) - [what’s new](https://github.com/giampaolo/psutil/blob/master/HISTORY.rst#580) - [diff](https://github.com/giampaolo/psutil/compare/release-5.7.3...release-5.8.0#files_bucket)
* 2020-10-23: 5.7.3 - what’s new - diff
* 2020-07-15: 5.7.2 - what’s new - diff
* 2020-07-15: 5.7.1 - what’s new - diff
* 2020-02-18: 5.7.0 - what’s new - diff
* 2019-11-26: 5.6.7 - what’s new - diff
* 2019-11-25: 5.6.6 - what’s new - diff
* 2019-11-06: 5.6.5 - what’s new - diff
* 2019-11-04: 5.6.4 - what’s new - diff
* 2019-06-11: 5.6.3 - what’s new - diff
* 2019-04-26: 5.6.2 - what’s new - diff
* 2019-03-11: 5.6.1 - what’s new - diff
* 2019-03-05: 5.6.0 - what’s new - diff
* 2019-02-15: 5.5.1 - what’s new - diff
* 2019-01-23: 5.5.0 - what’s new - diff
* 2018-10-30: 5.4.8 - what’s new - diff
* 2018-08-14: 5.4.7 - what’s new - diff
* 2018-06-07: 5.4.6 - what’s new - diff
* 2018-04-14: 5.4.5 - what’s new - diff
* 2018-04-13: 5.4.4 - what’s new - diff
* 2018-01-01: 5.4.3 - what’s new - diff
* 2017-12-07: 5.4.2 - what’s new - diff
* 2017-11-08: 5.4.1 - what’s new - diff
* 2017-10-12: 5.4.0 - what’s new - diff
* 2017-09-10: 5.3.1 - what’s new - diff
* 2017-09-01: 5.3.0 - what’s new - diff
* 2017-04-10: 5.2.2 - what’s new - diff
* 2017-03-24: 5.2.1 - what’s new - diff
* 2017-03-05: 5.2.0 - what’s new - diff
* 2017-02-07: 5.1.3 - what’s new - diff
* 2017-02-03: 5.1.2 - what’s new - diff
* 2017-02-03: 5.1.1 - what’s new - diff
* 2017-02-01: 5.1.0 - what’s new - diff
* 2016-12-21: 5.0.1 - what’s new - diff
* 2016-11-06: 5.0.0 - what’s new - diff
* 2016-10-05: 4.4.2 - what’s new - diff
* 2016-10-25: 4.4.1 - what’s new - diff
* 2016-10-23: 4.4.0 - what’s new - diff
* 2016-09-01: 4.3.1 - what’s new - diff
* 2016-06-18: 4.3.0 - what’s new - diff
* 2016-05-14: 4.2.0 - what’s new - diff
* 2016-03-12: 4.1.0 - what’s new - diff
* 2016-02-17: 4.0.0 - what’s new - diff
* 2016-01-20: 3.4.2 - what’s new - diff
* 2016-01-15: 3.4.1 - what’s new - diff
* 2015-11-25: 3.3.0 - what’s new - diff
* 2015-10-04: 3.2.2 - what’s new - diff
* 2015-09-03: 3.2.1 - what’s new - diff
* 2015-09-02: 3.2.0 - what’s new - diff
* 2015-07-15: 3.1.1 - what’s new - diff
* 2015-07-15: 3.1.0 - what’s new - diff
* 2015-06-18: 3.0.1 - what’s new - diff
* 2015-06-13: 3.0.0 - what’s new - diff
* 2015-02-02: 2.2.1 - what’s new - diff
* 2015-01-06: 2.2.0 - what’s new - diff
* 2014-09-26: 2.1.3 - what’s new - diff
* 2014-09-21: 2.1.2 - what’s new - diff
* 2014-04-30: 2.1.1 - what’s new - diff
* 2014-04-08: 2.1.0 - what’s new - diff
* 2014-03-10: 2.0.0 - what’s new - diff
* 2013-11-25: 1.2.1 - what’s new - diff
* 2013-11-20: 1.2.0 - what’s new - diff
* 2013-10-22: 1.1.2 - what’s new - diff
* 2013-10-08: 1.1.1 - what’s new - diff
* 2013-09-28: 1.1.0 - what’s new - diff
* 2013-07-12: 1.0.1 - what’s new - diff
* 2013-07-10: 1.0.0 - what’s new - diff
* 2013-05-03: 0.7.1 - what’s new - diff
* 2013-04-12: 0.7.0 - what’s new - diff
* 2012-08-16: 0.6.1 - what’s new - diff
* 2012-08-13: 0.6.0 - what’s new - diff
* 2012-06-29: 0.5.1 - what’s new - diff
* 2012-06-27: 0.5.0 - what’s new - diff
* 2011-12-14: 0.4.1 - what’s new - diff
* 2011-10-29: 0.4.0 - what’s new - diff
* 2011-07-08: 0.3.0 - what’s new - diff
* 2011-03-20: 0.2.1 - what’s new - diff
* 2010-11-13: 0.2.0 - what’s new - diff
* 2010-03-02: 0.1.3 - what’s new - diff
* 2009-05-06: 0.1.2 - what’s new - diff
* 2009-03-06: 0.1.1 - what’s new - diff
* 2009-01-27: 0.1.0 - what’s new - diff

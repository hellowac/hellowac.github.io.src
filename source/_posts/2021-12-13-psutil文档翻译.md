---
title: psutil文档-中文版
date: 2021-12-13 15:52:58
updated: 2021-12-15 00:45:09
toc: true
tags:
  - python
  - psutil
  - 翻译
  - 文档
categories:
  - 后端
  - 文档翻译
---

源文档: <https://psutil.readthedocs.io/en/latest/>

### **快速链接**

* [Home page](https://github.com/giampaolo/psutil)
* [Install](https://github.com/giampaolo/psutil/blob/master/INSTALL.rst)
* [Forum](http://groups.google.com/group/psutil/topics)
* [Download](https://pypi.org/project/psutil/#files)
* [Blog](https://gmpy.dev/tags/psutil)
* [Contributing](https://github.com/giampaolo/psutil/blob/master/CONTRIBUTING.md)
* [Development guide](https://github.com/giampaolo/psutil/blob/master/docs/DEVGUIDE.rst)
* [What’s new](https://github.com/giampaolo/psutil/blob/master/HISTORY.rst)

### **关于** (About)

psutil (python版的系统和进程实用包) 是一个跨平台库, 可用于在**Python**程序中检索正在运行的**进程**和**系统利用率**(CPU, 内存, 磁盘, 网络, 设备)的相关信息。该包实现了由Unix命令行工具提供的许多功能，例如: `ps`, `top`, `lsof`, `netstat`, `ifconfig`, `who`, `df`, `kill`, `free`, `nice`, `ionice`, `iostat`, `iotop`, `uptime`, `pidof`, `tty`, `taskset`, `pmap`. psutil 目前支持下面这些平台:

* **Linux**
* **Windows**
* **macOS**
* **FreeBSD**, **OpenBSD**, **NetBSD**
* **Sun Solaris**
* **AIX**

支持的Python版本是 **2.6**, **2.7** 和 **3.4+**. [PyPy](http://pypy.org/) 也可以工作.

当前psutil文档是作为单个HTML页面分发(发布)的。

<!-- more -->

## **基金** (Funding)

尽管psutil是免费软件并且会一直是，但该项目会从一些资金赞助中得到支持。就时间上而言, 持续解决漏洞报告和维护会花费我大量时间，几乎无法持续。如果您是一家大量使用psutil的商业公司, 您可以考虑通过[GitHub][github], [Open Collective][openCollective] 或 [PayPal][paypal]成为本项目的赞助商，同时会将您公司的logo展示在这儿和psutil文档中。

[github]: https://github.com/sponsors/giampaolo '赞助 giampaolo'
[openCollective]: https://opencollective.com/psutil '赞助 psutil'
[paypal]: https://www.paypal.com/cgi-bin/webscr?cmd=_s-xclick&hosted_button_id=A9ZS7PKKRM3S8 '赞助 giampaolo'

### 赞助 (Sponsors)

<p>
    <a href="https://tidelift.com/subscription/pkg/pypi-psutil?utm_source=pypi-psutil&amp;utm_medium=referral&amp;utm_campaign=readme">
        <img width="185" src="https://github.com/giampaolo/psutil/raw/master/docs/_static/tidelift-logo.svg?s=185&v=4">
    </a>
    &nbsp;&nbsp;
    <a href="https://sansec.io/">
        <img src="https://sansec.io/assets/images/logo.svg">
    </a>
</p>

添加您的[logo](https://github.com/sponsors/giampaolo)

### 支持 (Supporters)

<span>
  <a href="https://github.com/dbwiddis">
    <img height="40" width="40" title="Daniel Widdis" src="https://avatars1.githubusercontent.com/u/9291703?s=88&amp;v=4">
  </a>
  <a href="https://github.com/aristocratos">
    <img height="40" width="40" title="aristocratos" src="https://avatars3.githubusercontent.com/u/59659483?s=96&amp;v=4">
  </a>
  <a href="https://github.com/cybersecgeek">
    <img height="40" width="40" title="cybersecgeek" src="https://avatars.githubusercontent.com/u/12847926?v=4">
  </a>
  <a href="https://github.com/scoutapm-sponsorships">
    <img height="40" width="40" title="scoutapm-sponsorships" src="https://avatars.githubusercontent.com/u/71095532?v=4">
  </a>
  <a href="https://opencollective.com/chenyoo-hao">
    <img height="40" width="40" title="Chenyoo Hao" src="https://images.opencollective.com/chenyoo-hao/avatar/40.png">
  </a>
  <a href="https://opencollective.com/alexey-vazhnov">
    <img height="40" width="40" title="Alexey Vazhnov" src="https://images.opencollective.com/alexey-vazhnov/daed334/avatar/40.png">
  </a>
</span>

添加你的[头像](https://github.com/sponsors/giampaolo)

## **安装** (Install)

在 Linux, Windows, macOS:

```shell
pip install psutil
```

对于其他平台，请参阅更详细的[安装说明](https://github.com/giampaolo/psutil/blob/master/INSTALL.rst)

## **系统** (System related functions)

### CPU

#### **执行时间**

**psutil.cpu_times(percpu=False)** - [原文](https://psutil.readthedocs.io/en/latest/#psutil.cpu_times) <a name="psutil.cpu_times"></a>

返回一个命名元组的CPU时间信息，每个属性代表 CPU 在给定模式下花费的秒数。 属性可用性因平台而异。

* **user**: 进程在用户模式(user mode)下执行所花费的时间； 在 Linux 上，这也包括访客时间(guest time)。
* **system**: 进程在内核模式(kernel mode)下执行所花费的时间。
* **idle**: 空闲时间。

特定平台的字段:

* **nice** (UNIX): niced(优先) 进程在用户模式(user mode)下所花费的时间; 在 Linux 上，这也包括访客优先时间(guest_nice time)。
* **iowait** (Linux): 等待 I/O 完成所花费的时间。 这不计入空闲时间中。
* **irq** (Linux, BSD): 服务硬件中断所花费的时间。
* **softirq** (Linux): 服务软件中断所花费的时间。
* **steal** (Linux 2.6.11+): 在虚拟化环境中运行的其他操作系统所花费的时间。
* **guest** (Linux 2.6.24+): 在 Linux 内核的控制下为客户操作系统运行虚拟 CPU 所花费的时间
* **guest_nice** (Linux 3.2.0+): niced(优先) 访客进程所花费的时间 (用于在 Linux 内核控制下的客户操作系统的虚拟 CPU)
* **interrupt** (Windows): 服务硬件中断所花费的时间 ( 类似于 UNIX 上的“irq”)
* **dpc** (Windows): 服务延迟过程调用服务中断 (DPC) 所花费的时间； DPC 是运行优先级低于标准中断(interrupts)的中断。

**译注**: DPC是“Deferred Procedure Call”的缩写，意为推迟了的过程（函数）调用。参考: [延迟过程调用][windows-dpc]

当 _percpu_ 为 `True` 时，返回系统上每个逻辑 CPU 的命名元组列表。 列表的第一个元素指的是第一个 CPU，第二个元素指的是第二个 CPU，依此类推。 列表的顺序在调用之间是一致的。 Linux 上的示例输出：

```python
>>> import psutil
>>> psutil.cpu_times()
scputimes(user=17411.7, nice=77.99, system=3797.02, idle=51266.57, iowait=732.58, irq=0.01, softirq=142.43, steal=0.0, guest=0.0, guest_nice=0.0)
```

4.1.0 版本中更新: 对于Windows平台新增 **_interrupt_** 和 **_dpc_** 字段.

**⚠️警告**: CPU 时间总是应该随着时间的推移而增加，或者至少保持不变，那是因为时间不能倒流。令人惊讶的是，有时情况并非如此（至少在 Windows 和 Linux 上）, 参考 [#1210][issue-1210].

[issue-1210]: https://github.com/giampaolo/psutil/issues/1210#issuecomment-363046156 "CPU steal stuck at 100%"
[windows-dpc]: https://zh.wikipedia.org/wiki/%E5%BB%B6%E8%BF%9F%E8%BF%87%E7%A8%8B%E8%B0%83%E7%94%A8 "延迟过程调用"

#### **利用率**

**psutil.cpu_percent(interval=None, percpu=False)** - [原文](https://psutil.readthedocs.io/en/latest/#psutil.cpu_percent) <a name="psutil.cpu_percent"></a>

返回一个浮点数，以百分比形式表示当前系统范围内的 CPU 利用率。 当间隔 > `0.0` 时比较间隔前后经过的系统 CPU 时间（阻塞）。 当间隔为 `0.0` 或 `None` 时，比较自上次调用或模块导入以来经过的系统 CPU 时间，立即返回。这意味着第一次调用它时，它会返回一个你应该忽略的无意义的 `0.0` 值。在这种情况下，为了准确起见，建议在两次调用之间至少间隔 `0.1` 秒来调用此函数。当 **_percpu_** 为 `True` 时，返回一个浮点数列表，以百分比形式表示每个 CPU 的利用率。 列表的第一个元素指的是第一个 CPU，第二个元素指的是第二个 CPU，依此类推。列表的顺序在调用之间是一致的。

```python
>>> import psutil
>>> # blocking
>>> psutil.cpu_percent(interval=1)
2.0
>>> # non-blocking (percentage since last call)
>>> psutil.cpu_percent(interval=None)
2.9
>>> # blocking, per-cpu
>>> psutil.cpu_percent(interval=1, percpu=True)
[2.0, 1.0]
>>>
```

**⚠️警告**: 第一次使用 **_interval_** = `0.0` 或 `None` 调用此函数时，它将返回一个无意义的 `0.0` 值，您应该忽略该值。

#### **时间利用率详细**

**psutil.cpu_times_percent(interval=None, percpu=False)** - [原文](https://psutil.readthedocs.io/en/latest/#psutil.cpu_times_percent)

就像 [cpu_percent()](#psutil.cpu_percent) ，但提供 [psutil.cpu_times(percpu=True)](#psutil.cpu_times) 返回的每个 CPU 的**_时间利用率百分比。interval_** 和 **_percpu_** 参数的含义与 [cpu_percent()](#psutil.cpu_percent) 中的含义相同。 在 Linux 上，“**guest**”和“**guest\_nice**”百分比不计入“**user**”和“**user\_nice**”百分比。

**⚠️警告**: 第一次使用 **_interval_** = `0.0` 或 `None` 调用此函数时，它将返回一个无意义的 `0.0` 值，您应该忽略该值。

_4.1.0 版本中更新_: 对于Windows平台返回值将包含两个新字段 `interrupt` 和 `dpc` 。

#### **核心数量**

**psutil.cpu_count(logical=True)** - [原文](https://psutil.readthedocs.io/en/latest/#psutil.cpu_count)

返回系统中逻辑 CPU 的数量（与 Python 3.4 中的 [os.cpu_count][os.cpu_count] 相同）或 `None` 如果未确定。“逻辑 CPU”是指物理内核数乘以每个内核上可以运行的线程数（这称为超线程）。如果 **_logical_** 为 False，则仅返回物理内核的数量，如果未确定，则返回 `None`。 在 OpenBSD 和 NetBSD 上 `psutil.cpu_count(logical=False)` 总是返回 `None` 。下面是具有 2 个内核 + 超线程的系统示例:

[os.cpu_count]: https://docs.python.org/3/library/os.html#os.cpu_count "os.cpu_count"

```python
>>> import psutil
>>> psutil.cpu_count()
4
>>> psutil.cpu_count(logical=False)
2
```

请注意， `psutil.cpu_count()` 可能不一定等于当前进程可以使用的实际 CPU 数量。如果进程 CPU 亲和性已更改、正在使用 Linux cgroups 或（在 Windows 的情况下）在使用处理器组或具有超过 64 个 CPU 的系统上，这可能会有所不同。 可用 CPU 的数量可以通过以下方式获得：

```python
>>> len(psutil.Process().cpu_affinity())
1
psutil.cpu_stats()
```

#### **统计信息**

**psutil.cpu_stats()** - [原文](https://psutil.readthedocs.io/en/latest/#psutil.cpu_stats)

将各种 CPU 统计信息作为命名元组返回:

* **ctx_switches**: 自启动以来的上下文切换次数（自愿 + 非自愿）.
* **interrupts**: 自启动以来的中断数.
* **soft_interrupts**: 自启动以来的软件中断数。 在 Windows 和 SunOS 上始终设置为 0.
* **syscalls**: 自启动以来的系统调用数。 在 Linux 上始终设置为 0.

样例 (Linux):

```python
>>> import psutil
>>> psutil.cpu_stats()
scpustats(ctx_switches=20455687, interrupts=6598984, soft_interrupts=2134212, syscalls=0)
```

_4.1.0 版本中新增。_

#### **频率信息**

**psutil.cpu_freq(percpu=False)** - [原文](https://psutil.readthedocs.io/en/latest/#psutil.cpu_freq)

将 CPU 频率作为命名元组返回，包括以 Mhz 表示的当前、最小和最大频率。 在 Linux 中当前频率报告实时值，在所有其他平台上它代表标称的“固定”值。如果 **_percpu_** 为 `True` 并且系统支持 per-cpu 频率检索（仅限 Linux），则为每个 CPU 返回一个频率列表，如果不是，则返回一个包含单个元素的列表。如果无法确定最小值和最大值，则将它们设置为 0。

样例 (Linux):

```python
>>> import psutil
>>> psutil.cpu_freq()
scpufreq(current=931.42925, min=800.0, max=3500.0)
>>> psutil.cpu_freq(percpu=True)
[scpufreq(current=2394.945, min=800.0, max=3500.0),
 scpufreq(current=2236.812, min=800.0, max=3500.0),
 scpufreq(current=1703.609, min=800.0, max=3500.0),
 scpufreq(current=1754.289, min=800.0, max=3500.0)]
```

可用平台: Linux, macOS, Windows, FreeBSD

_5.1.0版本中新增。_

_5.5.1版本中更新：添加了 FreeBSD 支持。_

#### **负载信息**

**psutil.getloadavg()** - [原文](https://psutil.readthedocs.io/en/latest/#psutil.getloadavg)

以元组形式返回过去 1、5 和 15 分钟的平均系统负载。“负载”表示处于可运行状态的进程，要么使用 CPU，要么等待使用 CPU（例如，等待磁盘 I/O）。在 UNIX 系统上，这依赖于 [os.getloadavg][os.getloadavg]。在 Windows 上，这是通过使用 Windows API 来模拟的，该 API 产生一个线程，该线程保持在后台运行并每 5 秒更新一次结果，模仿 UNIX 行为。因此，在 Windows 上，第一次调用它，在接下来的 5 秒内，它将返回一个无意义的 (`0.0, 0.0, 0.0`) 元组。返回的数字仅在与系统上安装的 CPU 内核数相关时才有意义。 因此，例如，具有 10 个逻辑 CPU 的系统上的值 3.14 意味着系统负载在过去 N 分钟内为 31.4%。

[os.getloadavg]: https://docs.python.org/zh-cn/3/library/os.html#os.getloadavg "获得平均负载"

```python
>>> import psutil
>>> psutil.getloadavg()
(3.14, 3.89, 4.67)
>>> psutil.cpu_count()
10
>>> # percentage representation
>>> [x / psutil.cpu_count() * 100 for x in psutil.getloadavg()]
[31.4, 38.9, 46.7]
```

可用平台: Unix, Windows

_5.6.2 版本中新增。_

### 内存 (Memory)

#### **运行内存**

**psutil.virtual_memory()** - [原文](https://psutil.readthedocs.io/en/latest/#psutil.virtual_memory)

以包含以下字段的命名元组形式返回有关系统内存使用情况的统计信息，以**字节**为单位。 主要指标：

* `total`: 总物理内存（独占交换）。
* `available`: 可以立即分配给进程而无需系统进行交换的内存。这是通过根据平台对不同的内存值求和来计算的，它应该用于以跨平台方式监控实际内存使用情况。

其他指标:

* `used`: 使用的内存，计算方式因平台而异，仅供参考。 **total - free** 不一定匹配 **used**。
* `free`: 根本没有使用（归零）的随时可用的内存； 请注意，这并不反映实际可用内存（请改用可用(`available`)内存）。 **total - used** 不一定匹配 **free**。
* `active` (UNIX): 当前正在使用或最近使用的内存，因此它在 RAM 中。
* `inactive` (UNIX): 标记为未使用的内存。
* `buffers` (Linux, BSD): 缓存文件系统元数据等内容。
* `cached` (Linux, BSD): 缓存各种东西。
* `shared` (Linux, BSD): 可以被多个进程同时访问的内存。
* `slab` (Linux): 内核数据结构缓存。
* `wired` (BSD, macOS): 标记为始终保留在 RAM 中的内存。 它永远不会移动到磁盘。

已用(`used`)和可用(`available`)的总和不一定等于总数(`total`)。 在 Windows 上可用(`available`)和免费(`free`)是一样的。 请参阅 [meminfo.py][meminfo.py] 脚本并提供了有关如何以可读形式**转换字节**的示例。

[meminfo.py]: https://github.com/giampaolo/psutil/blob/master/scripts/meminfo.py "meminfo.py"

**注意**: 如果您只想知道跨平台方式还剩下多少物理内存，只需依赖可用(`available`)字段即可。

```python
>>> import psutil
>>> mem = psutil.virtual_memory()
>>> mem
svmem(total=10367352832, available=6472179712, percent=37.6, used=8186245120, free=2181107712, active=4748992512, inactive=2758115328, buffers=790724608, cached=3500347392, shared=787554304, slab=199348224)
>>>
>>> THRESHOLD = 100 * 1024 * 1024  # 100MB
>>> if mem.available <= THRESHOLD:
...     print("warning")
...
>>>
```

_4.2.0 版本中修改: 在Linux中新增了 `shared` 指标。_

_5.4.4 版本中修改: 在Linux中新增了 `slab` 指标。_

#### **交换内存**

**psutil.swap_memory()** - [原文](https://psutil.readthedocs.io/en/latest/#psutil.swap_memory)

将系统交换内存统计信息作为命名元组返回，包括以下字段：

* `total`: 以字节为单位的总交换内存
* `used`: 使用的交换内存（以字节为单位）
* `free`: 以字节为单位的空闲交换内存
* `percent`: 百分比使用率计算为 `(total - available) / total * 100`
* `sin`: 系统从磁盘换入的字节数（累计）
* `sout`: 系统从磁盘换出的字节数（累计）

Windows 上的 **sin** 和 **sout** 始终设置为 0。参阅 [meminfo.py][meminfo.py] 脚本，同时提供了有关如何以可读的形式**转换字节**的示例。

```python
>>> import psutil
>>> psutil.swap_memory()
sswap(total=2097147904L, used=886620160L, free=1210527744L, percent=42.3, sin=1050411008, sout=1906720768)
```

_5.2.3 版本中修改: 在 Linux 上，此函数依赖 /proc fs 而不是 sysinfo() 系统调用，以便它可以与 `psutil.PROCFS_PATH` 结合使用，以检索有关 Linux 容器（例如 Docker 和 Heroku）的内存信息。_

### 磁盘 (Disks)

#### **磁盘挂载信息**

**psutil.disk_partitions(all=False)** - [原文](https://psutil.readthedocs.io/en/latest/#psutil.disk_partitions)

将所有挂载的磁盘分区作为命名元组列表返回，包括设备、挂载点和文件系统类型，类似于 UNIX 上的“`df`”命令。如果 **_all_** 参数都为 `False` ，它会尝试仅区分和返回物理设备（例如硬盘、CD-ROM 驱动器、USB 密钥）并忽略所有其他设备（例如伪(pseudo)、内存、重复、无法访问的文件系统）。请注意， **_all_** 参数并非在所有系统上都完全可靠（例如，在 BSD 上，此参数被忽略）。请参阅提供示例用法的 [disk_usage.py][disk_usage.py] 脚本。 返回具有以下字段的命名元组列表：

[disk_usage.py]: https://github.com/giampaolo/psutil/blob/master/scripts/disk_usage.py "disk_usage.py"

* `device`: 设备路径（例如“`/dev/hda1`”）。 在 Windows 上，这是驱动器号（例如“`C:\\`”）。
* `mountpoint`: 挂载点路径（例如“`/`”）。 在 Windows 上，这是驱动器号（例如“`C:\\`”）。
* `fstype`: 分区文件系统（例如 UNIX 上的“`ext3`”或 Windows 上的“`NTFS`”）。
* `opts`: 一个逗号分隔的字符串，指示驱动器/分区的不同挂载选项。 平台相关。
* `maxfile`: 文件名可以具有的最大长度。
* `maxpath`: 路径名（目录名 + 基本文件名）的最大长度。

```python
>>> import psutil
>>> psutil.disk_partitions()
[sdiskpart(device='/dev/sda3', mountpoint='/', fstype='ext4', opts='rw,errors=remount-ro', maxfile=255, maxpath=4096),
 sdiskpart(device='/dev/sda7', mountpoint='/home', fstype='ext4', opts='rw', maxfile=255, maxpath=4096)]
```

_5.7.4 版本中修改: 新增 **maxfile** 和 **maxpath** 字段_

#### **磁盘利用率**

**psutil.disk_usage(path)** - [原文](https://psutil.readthedocs.io/en/latest/#psutil.disk_usage)

返回有关包含给定路径的分区的磁盘使用统计信息作为命名元组，包括以字节表示的总空间(**total**)、已用空间(**used**)和可用空间(**free**)，以及使用百分比(**percentage** usage)。如果路径(**_path_**)不存在，则引发 `OSError`。 从 Python 3.3 开始，这也可以作为 [shutil.disk_usage][shutil.disk_usage] 使用（参见 [BPO-12442][BPO-12442]）。 请参阅提供示例用法的 [disk_usage.py][disk_usage.py] 脚本。

[shutil.disk_usage]: https://docs.python.org/zh-cn/3/library/shutil.html#shutil.disk_usage. "shutil.disk_usage"
[BPO-12442]: https://bugs.python.org/issue12442 "BPO-12442"

```python
>>> import psutil
>>> psutil.disk_usage('/')
sdiskusage(total=21378641920, used=4809781248, free=15482871808, percent=22.5)
```

**注意**: UNIX 通常为 root 用户保留 5% 的总磁盘空间。UNIX 上的 **_total_** 和 **_used_** 字段是指总空间和已用空间，而 **_free_** 表示用户可用的空间，**_percent_** 表示用户利用率（参见[源代码][source-code]）。这就是为什么百分比(**_percent_**)值可能看起来比您预期的大 5%。 另请注意，这 4 个值都与“`df`” 命令行程序一致的。

[source-code]: https://github.com/giampaolo/psutil/blob/3dea30d583b8c1275057edb1b3b720813b4d0f60/psutil/_psposix.py#L123 "source-code"

_4.3.0 版本中修改: 百分比(**percent**)值考虑了`root`保留空间。_

#### **磁盘IO统计**

**psutil.disk_io_counters(perdisk=False, nowrap=True)** - [原文](https://psutil.readthedocs.io/en/latest/#psutil.disk_io_counters)

将系统范围的磁盘 I/O 统计信息作为命名元组返回，包括以下字段：

* `read_count`: 读取次数
* `write_count`: 写入次数
* `read_bytes`: 读取的字节数
* `write_bytes`: 写入的字节数

特定于平台的字段:

* `read_time`(除了 NetBSD 和 OpenBSD): 从磁盘读取所花费的时间（以毫秒为单位）
* `write_time`(除了 NetBSD 和 OpenBSD): 写入磁盘所花费的时间（以毫秒为单位）
* `busy_time`(Linux, FreeBSD):  花费在实际 I/O 上的时间（以毫秒为单位）
* `read_merged_count` (Linux): 合并读取的数量（参见 [iostats][iostats] 文档）
* `write_merged_count` (Linux): 合并写入的数量（请参阅 [iostats][iostats] 文档）

[iostats]: https://www.kernel.org/doc/Documentation/iostats.txt "iostats"

如果 **_perdisk_** 为 `True` ，则将系统上安装的每个物理磁盘的相同信息作为字典返回，分区名称作为键，上面描述的命名元组作为值。有关示例应用程序，参见 [iotoop.py][iotoop.py]。在某些系统（例如 Linux）上，在非常繁忙或寿命很长的系统上，内核返回的数字可能会溢出并换行（从零开始）。如果 **_nowrap_** 为 `True`，psutil 将在函数调用中检测并调整这些数字，并将“旧值”添加到“新值”，以便返回的数字始终增加或保持不变，但永远不会减少。`disk_io_counters.cache_clear()` 可用于使 **_nowrap_** 缓存无效。 在 Windows 上，可能需要首先从 cmd.exe 发出 `diskperf -y` 命令以启用 IO 计数器。 在无盘机器上，如果 **_perdisk_** 为 `True`，此函数将返回 `None` 或 `{}`。

[iotoop.py]: https://github.com/giampaolo/psutil/blob/master/scripts/iotop.py "io top"

```python
>>> import psutil
>>> psutil.disk_io_counters()
sdiskio(read_count=8141, write_count=2431, read_bytes=290203, write_bytes=537676, read_time=5868, write_time=94922)
>>>
>>> psutil.disk_io_counters(perdisk=True)
{'sda1': sdiskio(read_count=920, write_count=1, read_bytes=2933248, write_bytes=512, read_time=6016, write_time=4),
 'sda2': sdiskio(read_count=18707, write_count=8830, read_bytes=6060, write_bytes=3443, read_time=24585, write_time=1572),
 'sdb1': sdiskio(read_count=161, write_count=0, read_bytes=786432, write_bytes=0, read_time=44, write_time=0)}
```

**注意**: 在 Windows 上，可能需要先执行“`diskperf -y`”命令，否则该函数将找不到任何磁盘。

_5.3.0 版本中修改: 由于新的 nowrap 参数，数字不再在调用之间换行（从零开始）。_

_4.0.0 版本中修改: 添加了 **busy_time**(Linux, FreeBSD),**read_merged_count**和**write_merged_count** (Linux) 字段。_

_4.0.0 版本中修改: NetBSD 不再有 **read_time**和**write_time** 字段。_

### 网络 (Network)

#### **网络统计信息**

**psutil.net_io_counters(pernic=False, nowrap=True)** - [原文](https://psutil.readthedocs.io/en/latest/#psutil.net_io_counters)

将系统范围的网络 I/O 统计信息作为命名元组返回，包括以下属性：

* `bytes_sent`: 发送的字节数
* `bytes_recv`: 接收的字节数
* `packets_sent`: 发送的数据包数
* `packets_recv`: 收到的数据包数
* `errin`: 接收时的错误总数
* `errout`: 发送时的错误总数
* `dropin`: 丢弃的传入数据包总数
* `dropout`: 丢弃的传出数据包总数（在 macOS 和 BSD 上始终为 0）

如果 **_pernic_** 为 True，则将系统上安装的每个网络接口的相同信息作为字典返回，其中网络接口名称作为键，上面描述的命名元组作为值。在某些系统（例如 Linux）上，在非常繁忙或寿命很长的系统上，内核返回的数字可能会溢出并换行（从零开始）。如果 **_nowrap_** 为 `True` ，psutil 将在函数调用中检测并调整这些数字，并将“旧值”添加到“新值”，以便返回的数字始终增加或保持不变，但永远不会减少。`net_io_counters.cache_clear()` 可用于使 **_nowrap_** 缓存无效。 在没有网络接口的机器上，如果 **_pernic_** 为 `True` ，此函数将返回 `None` 或 `{}`。

```python
>>> import psutil
>>> psutil.net_io_counters()
snetio(bytes_sent=14508483, bytes_recv=62749361, packets_sent=84311, packets_recv=94888, errin=0, errout=0, dropin=0, dropout=0)
>>>
>>> psutil.net_io_counters(pernic=True)
{'lo': snetio(bytes_sent=547971, bytes_recv=547971, packets_sent=5075, packets_recv=5075, errin=0, errout=0, dropin=0, dropout=0),
'wlan0': snetio(bytes_sent=13921765, bytes_recv=62162574, packets_sent=79097, packets_recv=89648, errin=0, errout=0, dropin=0, dropout=0)}
```

示例应用程序另请参阅 [nettop.py][nettop.py] 和 [ifconfig.py][ifconfig.py] 。

[nettop.py]: https://github.com/giampaolo/psutil/blob/master/scripts/nettop.py "nettop.py"
[ifconfig.py]: https://github.com/giampaolo/psutil/blob/master/scripts/ifconfig.py "ifconfig.py"

*5.3.0 版本中修改: 由于新的 **_nowrap_** 参数，数字不再在调用之间换行（从零开始）。*

#### **网络连接信息**

**psutil.net_connections(kind='inet')** - [原文](https://psutil.readthedocs.io/en/latest/#psutil.net_connections)

以命名元组列表的形式返回系统范围的套接字连接。 每个命名元组提供 7 个属性：

* `fd`: 套接字文件描述符。 如果连接指向当前进程，则可以将其传递给 [socket.fromfd][socket.fromfd] 以获得可用的套接字对象。 在 Windows 和 SunOS 上，这始终设置为 `-1`。
* `family`: 地址族，[AF_INET][AF_INET]、[AF_INET6][AF_INET6] 或 [AF_UNIX][AF_UNIX]。
* `type`: 地址类型，[SOCK_STREAM][SOCK_STREAM][SOCK_STREAM]、[SOCK_DGRAM][SOCK_DGRAM] 或 [SOCK_SEQPACKET][SOCK_SEQPACKET]。
* `laddr`: 在 [AF_UNIX][AF_UNIX] 套接字的情况下，本地地址作为`(ip, port)`命名元组或路径(`path`)。 对于 UNIX 套接字，请参阅下面的注释。
* `raddr`: 在 [AF_UNIX][AF_UNIX] 套接字的情况下，远程地址作为`(ip, port)`命名元组或绝对路径(`path`)。当远程端点未连接时，您将获得一个空元组 (AF_INET*) 或 `""` (AF_UNIX)。 对于 UNIX 套接字，请参阅下面的注释。
* `status`: 表示 TCP 连接的状态。 返回值是 [psutil.CONN_*][psutil.CONN_*] 常量之一（字符串）。 对于 UDP 和 UNIX 套接字，这始终是 `psutil.CONN_NONE`。
* `pid`: 如果可检索打开套接字的进程的PID，否则为`None`。 在某些平台（例如 Linux）上，此字段的可用性根据进程权限（需要 root）而变化。

[socket.fromfd]: https://docs.python.org/3/library/socket.html#socket.fromfd "socket.fromfd"
[AF_INET]: https://docs.python.org/zh-cn/3/library/socket.html#socket.AF_INET "AF_INET"
[AF_INET6]: https://docs.python.org/zh-cn/3/library/socket.html#socket.AF_INET6 "AF_INET6"
[AF_UNIX]: https://docs.python.org/zh-cn/3/library/socket.html#socket.AF_UNIX "AF_UNIX"
[SOCK_STREAM]: https://docs.python.org/zh-cn/3/library/socket.html#socket.SOCK_STREAM "SOCK_STREAM"
[SOCK_DGRAM]: https://docs.python.org/zh-cn/3/library/socket.html#socket.SOCK_DGRAM "SOCK_DGRAM"
[SOCK_SEQPACKET]: https://docs.python.org/zh-cn/3/library/socket.html#socket.SOCK_SEQPACKET "SOCK_SEQPACKET"
[psutil.CONN_*]: https://psutil.readthedocs.io/en/latest/#connections-constants "psutil.CONN_* 常量"

**_kind_** 参数是一个字符串，用于过滤符合以下条件的连接：

| Kind 值 | 连接使用                       |
| ------- | ------------------------------ |
| "inet"  | IPv4 和 IPv6                   |
| "inet4" | IPv4                           |
| "inet6" | IPv6                           |
| "tcp"   | TCP                            |
| "tcp4"  | 基于 IPv4 的 TCP               |
| "tcp6"  | 基于 IPv6 的 TCP               |
| "udp"   | UDP                            |
| "udp4"  | 基于 IPv4 的 UDP               |
| "udp6"  | 基于 IPv6 的 UDP               |
| "unix"  | UNIX 套接字（UDP 和 TCP 协议） |
| "all"   | 所有可能的族和协议的总和       |

在 macOS 和 AIX 上，此功能需要 root 权限。 要获得每个进程的连接，请使用 [Process.connections()](#Process.connections)。 另请参阅 [netstat.py][netstat.py] 示例脚本。 例子：

[netstat.py]: https://github.com/giampaolo/psutil/blob/master/scripts/netstat.py "netstat.py"

```python
>>> import psutil
>>> psutil.net_connections()
[pconn(fd=115, family=<AddressFamily.AF_INET: 2>, type=<SocketType.SOCK_STREAM: 1>, laddr=addr(ip='10.0.0.1', port=48776), raddr=addr(ip='93.186.135.91', port=80), status='ESTABLISHED', pid=1254),
 pconn(fd=117, family=<AddressFamily.AF_INET: 2>, type=<SocketType.SOCK_STREAM: 1>, laddr=addr(ip='10.0.0.1', port=43761), raddr=addr(ip='72.14.234.100', port=80), status='CLOSING', pid=2987),
 pconn(fd=-1, family=<AddressFamily.AF_INET: 2>, type=<SocketType.SOCK_STREAM: 1>, laddr=addr(ip='10.0.0.1', port=60759), raddr=addr(ip='72.14.234.104', port=80), status='ESTABLISHED', pid=None),
 pconn(fd=-1, family=<AddressFamily.AF_INET: 2>, type=<SocketType.SOCK_STREAM: 1>, laddr=addr(ip='10.0.0.1', port=51314), raddr=addr(ip='72.14.234.83', port=443), status='SYN_SENT', pid=None)
 ...]
```

**注释**: (macOS 和 AIX) 除非以 root 用户身份运行，否则 [psutil.AccessDenied](#psutil.AccessDenied) 异常总是会抛出。 这是操作系统的限制，`lsof` 也是如此。

**注释**: (Solaris) 不支持 UNIX 套接字。

**注释**: (Linux, FreeBSD) UNIX 套接字的“raddr”字段始终设置为`“”`。 这是操作系统的限制。

**注释**: (OpenBSD) UNIX 套接字的“laddr”和“raddr”字段始终设置为`“”`。 这是操作系统的限制。

*2.1.0 版本中新增.*

*5.3.0 版本中修改: : 套接字“fd”现在设置为实数而不是 `-1`。*

*5.3.0 版本中修改: : “laddr”和“raddr”被命名为元组。*

#### **网卡地址信息**

**psutil.net_if_addrs()** - [原文](https://psutil.readthedocs.io/en/latest/#psutil.net_if_addrs)

返回与系统上安装的每个 NIC（网络接口卡）关联的地址作为字典，其键是 NIC 名称，值是分配给 NIC 的每个地址的命名元组列表。 每个命名元组包括 5 个字段：

* `family`: 地址族，[AF_INET][AF_INET] 或 [AF_INET6][AF_INET6] 或 [psutil.AF_LINK](#psutil.AF_LINK)，指的是 MAC 地址。
* `address`: 主 NIC 地址（始终设置）。
* `netmask`: 网络掩码地址（可能是 `None` ）。
* `broadcast`: 广播地址（可能是 `None` ）。
* `ptp`: 代表“点对点”(point to point)； 它是点对点接口（通常是 VPN）上的目标地址。 广播和 ptp 是互斥的。 可能为 `None`。

样例:

```python
>>> import psutil
>>> psutil.net_if_addrs()
{'lo': [snicaddr(family=<AddressFamily.AF_INET: 2>, address='127.0.0.1', netmask='255.0.0.0', broadcast='127.0.0.1', ptp=None),
        snicaddr(family=<AddressFamily.AF_INET6: 10>, address='::1', netmask='ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff', broadcast=None, ptp=None),
        snicaddr(family=<AddressFamily.AF_LINK: 17>, address='00:00:00:00:00:00', netmask=None, broadcast='00:00:00:00:00:00', ptp=None)],
 'wlan0': [snicaddr(family=<AddressFamily.AF_INET: 2>, address='192.168.1.3', netmask='255.255.255.0', broadcast='192.168.1.255', ptp=None),
           snicaddr(family=<AddressFamily.AF_INET6: 10>, address='fe80::c685:8ff:fe45:641%wlan0', netmask='ffff:ffff:ffff:ffff::', broadcast=None, ptp=None),
           snicaddr(family=<AddressFamily.AF_LINK: 17>, address='c4:85:08:45:06:41', netmask=None, broadcast='ff:ff:ff:ff:ff:ff', ptp=None)]}
>>>
```

另请参阅示例应用程序 [nettop.py][nettop.py] 和 [ifconfig.py][ifconfig.py]。

**注释**: 如果您对其他协议家族（例如 AF_BLUETOOTH）感兴趣，您可以使用更强大的 [netifaces][netifaces] 扩展。

**Note**: 你可以有多个相同系列的地址与每个接口相关联（这就是为什么 dict 值是列表）。

**Note**: Windows 不支持广播和 ptp，并且始终为 `None` 。

[netifaces]: https://pypi.org/project/netifaces/ "netifaces"

*3.0.0 版本中新增.*

*3.2.0 版本中修改: 添加了 **ptp** 字段。*

*4.4.0 版本中修改: 添加了对 Windows 上不再是 `None` 的网络掩码字段的支持。*

#### **网卡状态**

**psutil.net_if_stats()** - [原文](https://psutil.readthedocs.io/en/latest/#psutil.net_if_stats)

以字典形式返回系统上安装的每个 NIC（网络接口卡）的信息，其键是 NIC 名称，值是具有以下字段的命名元组：

* `isup`: 一个布尔值，指示 NIC 是否已启用并正在运行（意味着以太网电缆或 Wi-Fi 已连接）。
* `duplex`: 双工通信类型； 它可以是 [NIC_DUPLEX_FULL][NIC_DUPLEX_FULL]、[NIC_DUPLEX_HALF][NIC_DUPLEX_HALF] 或 [NIC_DUPLEX_UNKNOWN][NIC_DUPLEX_UNKNOWN]。
* `speed`: 以兆位 (MB) 表示的 NIC 速度，如果无法确定（例如“本地主机”），它将设置为 `0`。
* `mtu`: NIC 的最大传输单位，以字节为单位。

[NIC_DUPLEX_FULL]: #psutil.NIC_DUPLEX_FULL "psutil.NIC_DUPLEX_FULL"
[NIC_DUPLEX_HALF]: #psutil.NIC_DUPLEX_HALF "psutil.NIC_DUPLEX_HALF"
[NIC_DUPLEX_UNKNOWN]: #psutil.NIC_DUPLEX_UNKNOWN "psutil.NIC_DUPLEX_UNKNOWN"

样例:

```python
>>> import psutil
>>> psutil.net_if_stats()
{'eth0': snicstats(isup=True, duplex=<NicDuplex.NIC_DUPLEX_FULL: 2>, speed=100, mtu=1500),
 'lo': snicstats(isup=True, duplex=<NicDuplex.NIC_DUPLEX_UNKNOWN: 0>, speed=0, mtu=65536)}
```

另请参阅示例应用程序 [nettop.py][nettop.py] 和 [ifconfig.py][ifconfig.py]。

*3.0.0 版本中新增.*

*5.7.3 版本中修改: UNIX 上的 **isup** 同时还会检查 NIC 是否正在运行。*

### 传感器 (Sensors)

#### **温度**

**psutil.sensors_temperatures(fahrenheit=False)** - [原文](https://psutil.readthedocs.io/en/latest/#psutil.sensors_temperatures)

返回硬件温度。 每个条目都是一个命名元组，代表某个硬件温度传感器（它可能是 CPU、硬盘或其他东西，取决于操作系统及其配置）。所有温度均以摄氏度表示，除非华氏度(**_fahrenheit_**)设置为 True。 如果操作系统不支持传感器，则返回空字典。 例子：

```python
>>> import psutil
>>> psutil.sensors_temperatures()
{'acpitz': [shwtemp(label='', current=47.0, high=103.0, critical=103.0)],
 'asus': [shwtemp(label='', current=47.0, high=None, critical=None)],
 'coretemp': [shwtemp(label='Physical id 0', current=52.0, high=100.0, critical=100.0),
              shwtemp(label='Core 0', current=45.0, high=100.0, critical=100.0),
              shwtemp(label='Core 1', current=52.0, high=100.0, critical=100.0),
              shwtemp(label='Core 2', current=45.0, high=100.0, critical=100.0),
              shwtemp(label='Core 3', current=47.0, high=100.0, critical=100.0)]}
```

另请参阅示例应用脚本 [temperatures.py][temperatures.py] 和 [sensors.py][sensors.py]。

[temperatures.py]: https://github.com/giampaolo/psutil/blob/master/scripts/temperatures.py "temperatures.py"
[sensors.py]: https://github.com/giampaolo/psutil/blob/master/scripts/sensors.py "sensors.py"

可用平台: Linux, FreeBSD

*5.1.0 版本中新增.*

*5.5.0 版本中修改: 添加了对FreeBSD的支持。*

#### **风扇**

**psutil.sensors_fans()** - [原文](https://psutil.readthedocs.io/en/latest/#psutil.sensors_fans)

返回硬件风扇速度。 每个条目都是一个命名元组，代表某个硬件传感器风扇。 风扇速度以 RPM（每分钟转数）表示。 如果操作系统不支持传感器，则返回空字典。 例子：

```python
>>> import psutil
>>> psutil.sensors_fans()
{'asus': [sfan(label='cpu_fan', current=3200)]}
```

另请参阅示例应用脚本 [fans.py][fans.py] 和 [sensors.py][sensors.py]。

[fans.py]: https://github.com/giampaolo/psutil/blob/master/scripts/fans.py "fans.py"

可用平台: Linux

*5.2.0 版本中新增.*

#### **电池**

**psutil.sensors_battery()** - [原文](https://psutil.readthedocs.io/en/latest/#psutil.sensors_battery)

将电池状态信息作为包含以下值的命名元组返回。 如果未安装电池或无法确定指标，则返回 `None` 。

* `percent`: 电池电量剩余百分比。
* `secsleft`: 电池电量耗尽前还剩多少秒的粗略近似值。 如果连接了交流电源线，则此项设置为 [psutil.POWER_TIME_UNLIMITED](#psutil.POWER_TIME_UNLIMITED)。 如果无法确定，则将其设置为 [psutil.POWER_TIME_UNKNOWN](#psutil.POWER_TIME_UNKNOWN)。
* `power_plugged`: 如果 AC 电源线已连接，则为 `True` ，否则为 `False` ，如果无法确定则为 `None` 。

例子:

```python
>>> import psutil
>>>
>>> def secs2hours(secs):
...     mm, ss = divmod(secs, 60)
...     hh, mm = divmod(mm, 60)
...     return "%d:%02d:%02d" % (hh, mm, ss)
...
>>> battery = psutil.sensors_battery()
>>> battery
sbattery(percent=93, secsleft=16628, power_plugged=False)
>>> print("charge = %s%%, time left = %s" % (battery.percent, secs2hours(battery.secsleft)))
charge = 93%, time left = 4:37:08
```

另请参阅示例应用脚本 [battery.py][battery.py] 和 [sensors.py][sensors.py]。

[battery.py]: https://github.com/giampaolo/psutil/blob/master/scripts/battery.py  "battery.py"

可用平台: Linux, Windows, FreeBSD

*5.1.0 版本中新增.*

*5.4.2 版本中修改: 添加了 macOS 支持.*

### 其他系统信息(Other system info)

#### **启动时间**

**psutil.boot_time()** - [原文](https://psutil.readthedocs.io/en/latest/#psutil.boot_time)

返回自纪元(epoch)以来以秒表示的系统启动时间。 例子：

```python
>>> import psutil, datetime
>>> psutil.boot_time()
1389563460.0
>>> datetime.datetime.fromtimestamp(psutil.boot_time()).strftime("%Y-%m-%d %H:%M:%S")
'2014-01-12 22:51:00'
```

**注释**: 在 Windows 上，如果它在不同的进程中使用，这个函数可能会返回一个减少(off by) 1 秒的时间（参阅[问题 #1007][issue#1007]）。

[issue#1007]: https://github.com/giampaolo/psutil/issues/1007 "issue #1007"

#### **用户**

**psutil.users()** - [原文](https://psutil.readthedocs.io/en/latest/#psutil.users)

将当前连接在系统上的用户作为命名元组列表返回，包括以下字段：

* `name`: 用户名.
* `terminal`: 与用户关联的 `tty` 或 `伪tty` ，如果有，否则为 `None` 。
* `host`: 与条目关联的主机名（如果有）。
* `started`: 创建时间作为一个浮点数，以自纪元（epoch）以来的秒数表示。
* `pid`: 登录进程的 PID（如 sshd、tmux、gdm-session-worker 等）。 在 Windows 和 OpenBSD 上，PID 始终为 `None` 。

例子:

```python
>>> import psutil
>>> psutil.users()
[suser(name='giampaolo', terminal='pts/2', host='localhost', started=1340737536.0, pid=1352),
 suser(name='giampaolo', terminal='pts/3', host='localhost', started=1340737792.0, pid=1788)]
```

5.3.0 版本中修改: added “pid” field

## **进程** (Processes)

### **函数** (Functions)

#### **进程ID列表**

**psutil.pids()** - [原文](https://psutil.readthedocs.io/en/latest/#psutil.pids) <a name="psutil.pids"></a>

返回当前正在运行的**进程ID**(PID)的排序列表。 迭代所有进程并避免竞争条件 [process_iter()](#psutil.process_iter) 应该是首选。

```python
>>> import psutil
>>> psutil.pids()
[1, 2, 3, 5, 7, 8, 9, 10, 11, 12, 13, 14, 15, 17, 18, 19, ..., 32498]
```

*5.6.0 版本中修改: PIDs 排序后返回。*

#### **迭代进程**

**psutil.process_iter(attrs=None, ad_value=None)** - 原文 <a name="psutil.process_iter"></a>

返回一个迭代器，为本地机器上的所有正在运行的进程产生一个 [Process](#psutil.Process) 类实例。 这应该优于 [psutil.pids()](#psutil.pids) 来迭代进程，因为它不受竞争条件的影响。

每个 [Process](#psutil.Process) 实例只创建一次，然后在下次调用 [psutil.process_iter()](#psutil.process_iter) 时缓存（如果 PID 仍然存在）。 它还确保进程 PID 不被重用。

***attrs*** 和 ***ad_value*** 与 [Process.as_dict()](#Process.as_dict) 具有相同的含义。 如果指定了 ***attrs*** ，则 [Process.as_dict()](#Process.as_dict) 结果将存储为附加到返回的 [Process](#psutil.Process) 实例的 `info` 属性。 如果 ***attrs*** 是一个空列表，它将检索所有进程信息（比较慢）。

返回进程的排序顺序基于它们的 PID。

例子:

```python
>>> import psutil
>>> for proc in psutil.process_iter(['pid', 'name', 'username']):
...     print(proc.info)
...
{'name': 'systemd', 'pid': 1, 'username': 'root'}
{'name': 'kthreadd', 'pid': 2, 'username': 'root'}
{'name': 'ksoftirqd/0', 'pid': 3, 'username': 'root'}
...
```

创建类似于 `{pid: info, ...}` 数据结构的字典：

```python
>>> import psutil
>>> procs = {p.pid: p.info for p in psutil.process_iter(['name', 'username'])}
>>> procs
{1: {'name': 'systemd', 'username': 'root'},
 2: {'name': 'kthreadd', 'username': 'root'},
 3: {'name': 'ksoftirqd/0', 'username': 'root'},
 ...}
```

*5.3.0 版本中修改: 新增 “**attrs**” 和 “**ad_value**” 参数.*

#### **检查进程是否存在**

**psutil.pid_exists(pid)** - [原文](https://psutil.readthedocs.io/en/latest/#psutil.pid_exists)

检查给定的 PID 是否存在于当前进程列表中。 这比执行 `pid in psutil.pids()` 更快，应该是首选。

#### **等待进程终止**

**psutil.wait_procs(procs, timeout=None, callback=None)** - [原文](https://psutil.readthedocs.io/en/latest/#psutil.wait_procs)

等待 [Process](#psutil.Process) 实例列表终止的快捷函数。 返回一个 `(gone, alive)` 元组，指示哪些进程已经消失，哪些仍然活着。消失的进程实例将有一个新的 ***returncode*** 属性，表示 [Process.wait()](#Process.wait) 返回的进程退出状态。***callback*** 参数是一个函数，当正在等待的进程之一终止并且 [Process](#psutil.Process) 实例作为回调参数传递时会被调用（该实例还将具有 ***returncode*** 属性集合）。一旦所有进程终止或超时（单位:秒）发生，此函数将返回。 与 [Process.wait()](#Process.wait) 不同，如果发生超时，它不会引发 [TimeoutExpired](#psutil.TimeoutExpired)。 一个典型的用例可能是：

* 将 ***SIGTERM*** 信号发送到进程列表
* 给他们一些时间来终止
* 发送 ***SIGKILL*** 给那些还活着的进程

终止并等待此进程的所有子进程的示例：

```python
import psutil

def on_terminate(proc):
    print("process {} terminated with exit code {}".format(proc, proc.returncode))

procs = psutil.Process().children()
for p in procs:
    p.terminate()

gone, alive = psutil.wait_procs(procs, timeout=3, callback=on_terminate)
for p in alive:
    p.kill()
```

### **异常** (Exceptions)

#### **异常基类**

`class` **psutil.Error** - [原文](https://psutil.readthedocs.io/en/latest/#psutil.Error)

基本异常类。 所有其他异常都继承自这个异常。

#### **进程不存在**

`class` **psutil.NoSuchProcess(pid, name=None, msg=None)** - [原文](https://psutil.readthedocs.io/en/latest/#psutil.NoSuchProcess) <a name="psutil.NoSuchProcess"></a>

当在当前进程列表中找不到具有给定 pid 的进程或进程不再存在时，由 [Process](#psutil.Process) 类的方法抛出。 ***name*** 是进程消失之前的名称，只有在之前调用 [Process.name()](#Process.name) 时才会设置。

#### **僵尸进程**

`class` **psutil.ZombieProcess(pid, name=None, ppid=None, msg=None)** - [原文](https://psutil.readthedocs.io/en/latest/#psutil.ZombieProcess) <a name="psutil.ZombieProcess"></a>

在 UNIX 上查询僵尸进程（Windows 没有僵尸进程）时，这可能由 [Process](#psutil.Process) 类的方法抛出。 如果在进程变成僵尸之前调用 [Process.name()](#Process.name) 或 [Process.ppid()](#Process.ppid) 方法，则 ***name*** 和 ***ppid*** 属性可用。

**注释**: 这是 [NoSuchProcess](#psutil.NoSuchProcess) 的子类，因此如果对检索僵尸进程不感兴趣（例如，在使用 [process_iter()](#psutil.process_iter) 时），可以忽略此异常并只捕获 [NoSuchProcess](#psutil.NoSuchProcess) 。

*3.0.0 版本中新增.*

#### **无权限**

`class` **psutil.AccessDenied(pid=None, name=None, msg=None)** - [原文](https://psutil.readthedocs.io/en/latest/#psutil.AccessDenied) <a name="psutil.AccessDenied"></a>

当由于权限不足而拒绝执行操作时，由 [Process](#psutil.Process) 类的方法抛出。 如果之前调用了 [Process.name()](#Process.name)，则 ***name*** 属性可用。

#### **超时**

`class` **psutil.TimeoutExpired(seconds, pid=None, name=None, msg=None)** - [原文](https://psutil.readthedocs.io/en/latest/#psutil.TimeoutExpired) <a name="psutil.TimeoutExpired"></a>

如果超时到期并且进程仍然存在，则由 [Process.wait()](#Process.wait) 方法引发。 如果之前调用了 [Process.name()](#Process.name)，则 ***name*** 属性可用。

### 进程类 (Process class)

`class` **psutil.Process(pid=None)** - [原文](https://psutil.readthedocs.io/en/latest/#psutil.Process) <a name="psutil.Process"></a>

代表具有给定 ***pid*** 的系统(OS)进程。 如果省略 ***pid*** ，则使用当前进程的 ***pid*** ([os.getpid][os.getpid])。 如果 ***pid*** 不存在，则抛出 [NoSuchProcess](#psutil.NoSuchProcess) 异常。 在 Linux 上， ***pid*** 也可以指 线程ID（[threads()](#Process.threads) 方法返回的 ***id*** 字段）。 访问该类的方法时，始终准备捕获 [NoSuchProcess](#psutil.NoSuchProcess) 和 [AccessDenied](#psutil.AccessDenied) 异常。 内建函数 [hash][[builtin.hash]] 可用于此类的实例，以便随着时间的推移唯一地标识进程（hash值由 `进程 PID + 创建时间` 混合后确定）。 因此，它也可以与 [set][typs.set] 一起使用。

**注释**： 为了同时有效地获取有关进程的多个信息，请确保使用 [oneshot()](#Process.oneshot) 上下文管理器或 [as_dict()](#Process.as_dict) 实例方法。

**注释**： 此类和进程绑定的方式是通过其唯一 PID 。这意味着如果进程终止并且操作系统重用其 PID，最终可能会与另一个进程交互。抢先检查进程身份（通过 PID + 创建时间）的唯一例外是以下方法：[nice()](#Process.nice) (set), [ionice()](#Process.ionice) (set), [cpu_affinity()](#Process.cpu_affinity) (set), [rlimit()](#Process.rlimit) (set) , [children()](#Process.children), [parent()](#Process.parent), [parents()](Process.parents), [suspend()](#Process.suspend), [resume()](#Process.resume), [send_signal()](#Process.send_signal), [terminate()](#Process.terminate), [kill()](#Process.kill)。为了防止所有其他方法出现此问题，您可以在查询进程之前使用 [is_running()](#Process.is_running) 或 [process_iter()](#psutil.process_iter) 以防您迭代所有进程。但必须注意的是，除非处理非常“旧(old)”（非活动(inactive)）的 [Process](#psutil.Process) 实例，否则这几乎不会构成问题。

[os.getpid]: https://docs.python.org/3/library/os.html#os.getpid "os.getpid"
[builtin.hash]: https://docs.python.org/zh-cn/3/library/functions.html#hash "builtin hash"
[typs.set]: https://docs.python.org/zh-cn/3/library/stdtypes.html#types-set. "内置类型 Set"

**译注**: 进程类方法一览

* Process.[oneshot()](#Process.oneshot) - 快照
* Process.[pid](#Process.pid) - 进程ID
* Process.[ppid()](#Process.ppid) - 父进程ID
* Process.[name()](#Process.name) - 进程名称
* Process.[exe()](#Process.exe) - 可执行文件绝对路径
* Process.[cmdline()](#Process.cmdline) - 执行命令行
* Process.[environ()](#Process.environ) - 环境变量
* Process.[create_time()](#Process.create_time) - 创建时间
* Process.[as_dict(attrs=None, ad_value=None)](#Process.as_dict) - 字典信息
* Process.[parent()](#Process.parent) - 父进程
* Process.[parents()](#Process.parents) - 父进程列表
* Process.[status()](#Process.status) - 进程状态
* Process.[cwd()](#Process.cwd) - 执行目录
* Process.[username()](#Process.username) - 所属用户名
* Process.[uids()](#Process.uids) - 用户ID
* Process.[gids()](#Process.gids) - 组ID
* Process.[terminal()](#Process.terminal) - 终端
* Process.[nice(value=None)](#Process.nice) - 优先级
* Process.[ionice(ioclass=None, value=None)](#Process.ionice) - I/O优先级
* Process.[rlimit(resource, limits=None)](#Process.rlimit) - 资源限制
* Process.[io_counters()](#Process.io_counters)
* Process.[num_ctx_switches()](#Process.num_ctx_switches)
* Process.[num_fds()](#Process.num_fds)
* Process.[num_handles()](#Process.num_handles)
* Process.[num_threads()](#Process.num_threads)
* Process.[threads()](#Process.threads)
* Process.[cpu_times()](#Process.cpu_times)
* Process.[cpu_percent(interval=None)](#Process.cpu_percent)
* Process.[cpu_affinity(cpus=None)](#Process.cpu_affinity)
* Process.[cpu_num()](#Process.cpu_num)
* Process.[memory_info()](#Process.memory_info)
* Process.[memory_info_ex()](#Process.memory_info_ex)
* Process.[memory_full_info()](#Process.memory_full_info)
* Process.[memory_percent(memtype="rss")](#Process.memory_percent)
* Process.[memory_maps(grouped=True)](#Process.memory_maps)
* Process.[children(recursive=False)](#Process.children)
* Process.[open_files()](#Process.open_files)
* Process.[connections(kind="inet")](#Process.connections)
* Process.[is_running()](#Process.is_running)
* Process.[send_signal(signal)](#Process.send_signal)
* Process.[suspend()](#Process.suspend)
* Process.[resume()](#Process.resume)
* Process.[terminate()](#Process.terminate)
* Process.[kill()](#Process.kill)
* Process.[wait(timeout=None)](#Process.wait)
* pstuil.[Popen](#Popen)

#### **快照**

**Process.oneshot()** - [原文](https://psutil.readthedocs.io/en/latest/#psutil.Process.oneshot) <a name="Process.oneshot" ></a>
  
实例的上下文管理器可显著加快同时检索多个进程信息的速度。内部不同的进程信息（例如 [name()](#Process.name), [ppid()](#Process.ppid), [uids()](#Process.uids), [create_time()](#Process.create_time), ...）可以通过使用相同的例程获取，但只返回一个值，其他值被丢弃。当使用上下文管理器时，内部只执行一次（在下面的 [name()](#Process.name) 示例中），返回感兴趣的值并缓存其他值。共享相同内部例程的后续调用将返回缓存值。 退出上下文管理器块时清除缓存。建议是每次检索有关该进程的多个信息时都使用此方法。 如果很幸运，获取值将会得到极大的加速。 例子：

```python
>>> import psutil
>>> p = psutil.Process()
>>> with p.oneshot():
...     p.name()  # execute internal routine once collecting multiple info
...     p.cpu_times()  # return cached value
...     p.cpu_percent()  # return cached value
...     p.create_time()  # return cached value
...     p.ppid()  # return cached value
...     p.status()  # return cached value
...
>>>
```

以下是可以利用加速的方法列表，具体取决于使用的平台。在下表中，垂直列表示哪些进程方法可以在某个平台内调用时内部有效地组合在一起。最后一行 (speedup) 显示了将所有方法一起调用时可以获得的加速比的近似值（最佳情况）。

**译注**: 原文说的是 “horizontal emtpy rows” 水平空行，但根据表格实际内容，应为某个平台对应的垂直列，并且原文的 “The last column” 应该是指最后一行。

| **Linux**                                       | **Windows**                                     | **macOS**                                       | **BSD**                                         | **SunOS**                                   | **AIX**                                     |
| ----------------------------------------------- | ----------------------------------------------- | ----------------------------------------------- | ----------------------------------------------- | ------------------------------------------- | ------------------------------------------- |
| [cpu_num()](#Process.cpu_num)                   | [cpu_percent()](#Process.cpu_percent)           | [cpu_percent()](#Process.cpu_percent)           | [cpu_num()](#Process.cpu_num)                   | [name()](#Process.name)                     | [name()](#Process.name)                     |
| [cpu_percent()](#Process.cpu_percent)           | [cpu_times()](#Process.cpu_times)               | [cpu_times()](#Process.cpu_times)               | [cpu_percent()](#Process.cpu_percent)           | [cmdline()](#Process.cmdline)               | [cmdline()](#Process.cmdline)               |
| [cpu_times()](#Process.cpu_times)               | [io_counters()](#Process.io_counters)           | [memory_info()](#Process.memory_info)           | [cpu_times()](#Process.cpu_times)               | [create_time()](#Process.create_time)       | [create_time()](#Process.create_time)       |
| [create_time()](#Process.create_time)           | [memory_info()](#Process.memory_info)           | [memory_percent()](#Process.memory_percent)     | [create_time()](#Process.create_time)           | -                                           | -                                           |
| [name()](#Process.name)                         | [memory_maps()](#Process.memory_maps)           | [num_ctx_switches()](#Process.num_ctx_switches) | [gids()](#Process.gids)                         | [memory_info()](#Process.memory_info)       | [memory_info()](#Process.memory_info)       |
| [ppid()](#Process.ppid)                         | [num_ctx_switches()](#Process.num_ctx_switches) | [num_threads()](#Process.num_threads)           | [io_counters()](#Process.io_counters)           | [memory_percent()](#Process.memory_percent) | [memory_percent()](#Process.memory_percent) |
| [status()](#Process.status)                     | [num_handles()](#Process.num_handles)           | -                                               | [name()](#Process.name)                         | [num_threads()](#Process.num_threads)       | [num_threads()](#Process.num_threads)       |
| [terminal()](#Process.terminal)                 | [num_threads()](#Process.num_threads)           | [create_time()](#Process.create_time)           | [memory_info()](#Process.memory_info)           | [ppid()](#Process.ppid)                     | [ppid()](#Process.ppid)                     |
| -                                               | [username()](#Process.username)                 | [gids()](#Process.gids)                         | [memory_percent()](#Process.memory_percent)     | [status()](#Process.status)                 | [status()](#Process.status)                 |
| [gids()](#Process.gids)                         | -                                               | [name()](#Process.name)                         | [num_ctx_switches()](#Process.num_ctx_switches) | [terminal()](#Process.terminal)             | [terminal()](#Process.terminal)             |
| [num_ctx_switches()](#Process.num_ctx_switches) | [exe()](#Process.exe)                           | [ppid()](#Process.ppid)                         | [ppid()](#Process.ppid)                         | -                                           | -                                           |
| [num_threads()](#Process.num_threads)           | [name()](#Process.name)                         | [status()](#Process.status)                     | [status()](#Process.status)                     | [gids()](#Process.gids)                     | [gids()](#Process.gids)                     |
| [uids()](#Process.uids)                         | -                                               | [terminal()](#Process.terminal)                 | [terminal()](#Process.terminal)                 | [uids()](#Process.uids)                     | [uids()](#Process.uids)                     |
| [username()](#Process.username)                 | -                                               | [uids()](#Process.uids)                         | [uids()](#Process.uids)                         | [username()](#Process.username)             | [username()](#Process.username)             |
| -                                               | -                                               | [username()](#Process.username)                 | [username()](#Process.username)                 | -                                           | -                                           |
| [memory_full_info()](#Process.memory_full_info) | -                                               | -                                               | -                                               | -                                           | -                                           |
| [memory_maps()](#Process.memory_maps)           | -                                               | -                                               | -                                               | -                                           | -                                           |
| speedup: +2.6x                                  | speedup: +1.8x / +6.5x                          | speedup: +1.9x                                  | speedup: +2.0x                                  | speedup: +1.3x                              | speedup: +1.3x                              |

*5.0.0 版本中新增.*

#### **进程ID**

**Process.pid** - [原文](https://psutil.readthedocs.io/en/latest/#psutil.Process.pid) <a name="Process.pid" ></a>

进程PID 。 这是该类的唯一一个属性（只读）。

#### **父进程ID**

**Process.ppid()** - [原文](https://psutil.readthedocs.io/en/latest/#psutil.Process.ppid) <a name="Process.ppid" ></a>

返回父进程PID。 在 Windows 上，第一次调用后会缓存返回值。在 POSIX 类型机器上时则不会缓存，因为如果进程变成僵尸进程， ***ppid*** 可能会改变，另见 [parent()](#Process.parent) 和 [parents()](#Process.parents) 方法。

#### **进程名称**

**Process.name()** - [原文](https://psutil.readthedocs.io/en/latest/#psutil.Process.name) <a name="Process.name" ></a>

返回进程名称. 在 Windows 上，第一次调用后会缓存返回值。在 POSIX 类型机器上时则不会缓存， 因为进程名称可能会改变。 另请参阅如何[按名称查找进程](#find-process-by-name)。

#### **可执行文件绝对路径**

**Process.exe()** - [原文](https://psutil.readthedocs.io/en/latest/#psutil.Process.exe) <a name="Process.exe" ></a>

进程的可执行文件绝对路径。 在某些系统上，这也可能是一个空字符串。 返回值在第一次调用后被缓存。

```python
>>> import psutil
>>> psutil.Process().exe()
'/usr/bin/python2.7'
```

#### **执行命令行**

**Process.cmdline()** - [原文](https://psutil.readthedocs.io/en/latest/#psutil.Process.cmdline) <a name="Process.cmdline" ></a>

此进程的作为字符串列表的命令号调用。 由于进程的命令行可能会更改，因此不会缓存返回值。

```python
>>> import psutil
>>> psutil.Process().cmdline()
['python', 'manage.py', 'runserver']
```

#### **环境变量**

**Process.environ()** - [原文](https://psutil.readthedocs.io/en/latest/#psutil.Process.environ) <a name="Process.environ" ></a>

进程的作为字典的环境变量。 **注意**：这可能不会反映进程开始后所做的更改。

```python
>>> import psutil
>>> psutil.Process().environ()
{'LC_NUMERIC': 'it_IT.UTF-8', 'QT_QPA_PLATFORMTHEME': 'appmenu-qt5', 'IM_CONFIG_PHASE': '1', 'XDG_GREETER_DATA_DIR': '/var/lib/lightdm-data/giampaolo', 'GNOME_DESKTOP_SESSION_ID': 'this-is-deprecated', 'XDG_CURRENT_DESKTOP': 'Unity', 'UPSTART_EVENTS': 'started starting', 'GNOME_KEYRING_PID': '', 'XDG_VTNR': '7', 'QT_IM_MODULE': 'ibus', 'LOGNAME': 'giampaolo', 'USER': 'giampaolo', 'PATH': '/home/giampaolo/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin:/home/giampaolo/svn/sysconf/bin', 'LC_PAPER': 'it_IT.UTF-8', 'GNOME_KEYRING_CONTROL': '', 'GTK_IM_MODULE': 'ibus', 'DISPLAY': ':0', 'LANG': 'en_US.UTF-8', 'LESS_TERMCAP_se': '\x1b[0m', 'TERM': 'xterm-256color', 'SHELL': '/bin/bash', 'XDG_SESSION_PATH': '/org/freedesktop/DisplayManager/Session0', 'XAUTHORITY': '/home/giampaolo/.Xauthority', 'LANGUAGE': 'en_US', 'COMPIZ_CONFIG_PROFILE': 'ubuntu', 'LC_MONETARY': 'it_IT.UTF-8', 'QT_LINUX_ACCESSIBILITY_ALWAYS_ON': '1', 'LESS_TERMCAP_me': '\x1b[0m', 'LESS_TERMCAP_md': '\x1b[01;38;5;74m', 'LESS_TERMCAP_mb': '\x1b[01;31m', 'HISTSIZE': '100000', 'UPSTART_INSTANCE': '', 'CLUTTER_IM_MODULE': 'xim', 'WINDOWID': '58786407', 'EDITOR': 'vim', 'SESSIONTYPE': 'gnome-session', 'XMODIFIERS': '@im=ibus', 'GPG_AGENT_INFO': '/home/giampaolo/.gnupg/S.gpg-agent:0:1', 'HOME': '/home/giampaolo', 'HISTFILESIZE': '100000', 'QT4_IM_MODULE': 'xim', 'GTK2_MODULES': 'overlay-scrollbar', 'XDG_SESSION_DESKTOP': 'ubuntu', 'SHLVL': '1', 'XDG_RUNTIME_DIR': '/run/user/1000', 'INSTANCE': 'Unity', 'LC_ADDRESS': 'it_IT.UTF-8', 'SSH_AUTH_SOCK': '/run/user/1000/keyring/ssh', 'VTE_VERSION': '4205', 'GDMSESSION': 'ubuntu', 'MANDATORY_PATH': '/usr/share/gconf/ubuntu.mandatory.path', 'VISUAL': 'vim', 'DESKTOP_SESSION': 'ubuntu', 'QT_ACCESSIBILITY': '1', 'XDG_SEAT_PATH': '/org/freedesktop/DisplayManager/Seat0', 'LESSCLOSE': '/usr/bin/lesspipe %s %s', 'LESSOPEN': '| /usr/bin/lesspipe %s', 'XDG_SESSION_ID': 'c2', 'DBUS_SESSION_BUS_ADDRESS': 'unix:abstract=/tmp/dbus-9GAJpvnt8r', '_': '/usr/bin/python', 'DEFAULTS_PATH': '/usr/share/gconf/ubuntu.default.path', 'LC_IDENTIFICATION': 'it_IT.UTF-8', 'LESS_TERMCAP_ue': '\x1b[0m', 'UPSTART_SESSION': 'unix:abstract=/com/ubuntu/upstart-session/1000/1294', 'XDG_CONFIG_DIRS': '/etc/xdg/xdg-ubuntu:/usr/share/upstart/xdg:/etc/xdg', 'GTK_MODULES': 'gail:atk-bridge:unity-gtk-module', 'XDG_SESSION_TYPE': 'x11', 'PYTHONSTARTUP': '/home/giampaolo/.pythonstart', 'LC_NAME': 'it_IT.UTF-8', 'OLDPWD': '/home/giampaolo/svn/curio_giampaolo/tests', 'GDM_LANG': 'en_US', 'LC_TELEPHONE': 'it_IT.UTF-8', 'HISTCONTROL': 'ignoredups:erasedups', 'LC_MEASUREMENT': 'it_IT.UTF-8', 'PWD': '/home/giampaolo/svn/curio_giampaolo', 'JOB': 'gnome-session', 'LESS_TERMCAP_us': '\x1b[04;38;5;146m', 'UPSTART_JOB': 'unity-settings-daemon', 'LC_TIME': 'it_IT.UTF-8', 'LESS_TERMCAP_so': '\x1b[38;5;246m', 'PAGER': 'less', 'XDG_DATA_DIRS': '/usr/share/ubuntu:/usr/share/gnome:/usr/local/share/:/usr/share/:/var/lib/snapd/desktop', 'XDG_SEAT': 'seat0'}
```

*4.0.0 版本中新增.*

*5.3.0 版本中修改: 新增 SunOS 支持。*

*5.6.3 版本中修改: 新增 AIX 支持。*

*5.7.3 版本中修改: 新增 BSD 支持。*

#### **创建时间**

**Process.create_time()** - [原文](https://psutil.readthedocs.io/en/latest/#psutil.Process.create_time) <a name="Process.create_time" ></a>

进程创建时间，以自纪元以来的秒数表示的浮点数。 返回值在第一次调用后被缓存。

```python
>>> import psutil, datetime
>>> p = psutil.Process()
>>> p.create_time()
1307289803.47
>>> datetime.datetime.fromtimestamp(p.create_time()).strftime("%Y-%m-%d %H:%M:%S")
'2011-03-05 18:03:52'
```

#### **字典信息**

**Process.as_dict(attrs=None, ad_value=None)** - [原文](https://psutil.readthedocs.io/en/latest/#psutil.Process.as_dict) <a name="Process.as_dict" ></a>

以字典形式检索进程的多个信息的实例方法。如果指定了 ***attrs*** ，则它必须是反映 [Process](#psutil.Process) 类可用的属性名称的字符串列表。以下是可能的字符串值列表：`'cmdline'`, `'connections'`, `'cpu_affinity'`, `'cpu_num'`, `'cpu_percent'`, `'cpu_times'`, `'create_time'`, `'cwd'`, `'environ'`, `'exe'`, `'gids'`, `'io_counters'`, `'ionice'`, `'memory_full_info'`, `'memory_info'`, `'memory_maps'`, `'memory_percent'`, `'name'`, `'nice'`, `'num_ctx_switches'`, `'num_fds'`, `'num_handles'`, `'num_threads'`, `'open_files'`, `'pid'`, `'ppid'`, `'status'`, `'terminal'`, `'threads'`, `'uids'`, `'username'`. 如果没有传递 ***attrs*** 参数，则假定为所有公共的只读属性。***ad_value*** 是分配给字典键的值，以防在检索该特定进程信息时引发 [AccessDenied](#psutil.AccessDenied) 或 [ZombieProcess](#psutil.ZombieProcess) 异常。 在内部， [as_dict()](#Process.as_dict) 使用 [oneshot()](#Process.oneshot) 上下文管理器，因此也无需使用它。

```python
>>> import psutil
>>> p = psutil.Process()
>>> p.as_dict(attrs=['pid', 'name', 'username'])
{'username': 'giampaolo', 'pid': 12366, 'name': 'python'}
>>>
>>> # get a list of valid attrs names
>>> list(psutil.Process().as_dict().keys())
['status', 'cpu_num', 'num_ctx_switches', 'pid', 'memory_full_info', 
 'connections', 'cmdline', 'create_time', 'ionice', 'num_fds', 
 'memory_maps', 'cpu_percent', 'terminal', 'ppid', 'cwd', 'nice', 
 'username', 'cpu_times', 'io_counters', 'memory_info', 'threads', 
 'open_files', 'name', 'num_threads', 'exe', 'uids', 'gids', 
 'cpu_affinity', 'memory_percent', 'environ']
```

*3.0.0 版本中修改: **ad_value** 在引发 [ZombieProcess](#psutil.ZombieProcess) 异常时也使用，不仅是 [AccessDenied](#psutil.AccessDenied)。*

*4.5.0 版本中修改: 由于 [oneshot()](#Process.oneshot) 上下文管理器，[as_dict()](#Process.as_dict) 的速度要快得多。*

#### **父进程**

**Process.parent()** - [原文](https://psutil.readthedocs.io/en/latest/#psutil.Process.parent) <a name="Process.parent" ></a>

将父进程作为 [Process](#psutil.Process) 对象返回的实例方法，抢先检查 PID 是否已被重用。 如果没有已知的父 PID，则返回 `None` 。 另请参见 [ppid()](#Process.ppid) 和 [parents()](#Process.parents) 方法。

#### **父进程列表**

**Process.parents()** - [原文](https://psutil.readthedocs.io/en/latest/#psutil.Process.parents) <a name="Process.parents" ></a>

以列表形式返回当前进程的所有父进程的实例方法, 如果没有父进程，返回空列表。同样参考 [ppid()](#Process.ppid) 和 [parent()](#Process.parent) 方法.

译注例子:

```python
>>> psutil.Process().parents()
[psutil.Process(pid=79791, name='zsh', status='running', started='2021-12-09 17:23:11'), psutil.Process(pid=3483, name='Code Helper (Renderer)', status='running', started='2021-12-02 16:07:48'), psutil.Process(pid=3479, name='Code Helper (Renderer)', status='running', started='2021-12-02 16:07:48'), psutil.Process(pid=471, name='Electron', status='running', started='2021-12-02 16:07:35'), psutil.Process(pid=1, name='launchd', status='running', started='2021-12-02 16:07:20'), psutil.Process(pid=0, name='kernel_task', status='running', started='2021-12-02 16:07:20')]
```

*5.6.0 版本中新增.*

#### **进程状态**

**Process.status()** - [原文](https://psutil.readthedocs.io/en/latest/#psutil.Process.status) <a name="Process.status" ></a>

以字符串方式返回当前进程状态。 返回的字符串是 [psutil.STATUS_*](#process-status-constant) 常量之一。

译注例子:

```python
>>> psutil.Process().status()
'running'
```

#### **执行目录**

**Process.cwd()** - [原文](https://psutil.readthedocs.io/en/latest/#psutil.Process.cwd) <a name="Process.cwd" ></a>

以绝对路径的方式返回进程当前执行目录。

译注例子:

```python
>>> psutil.Process().cwd()
'/xxxx/xxxx/scripts/demo'
```

*5.6.4 版本中修改: 新增 NetBSD 支持。*

#### **所属用户名**

**Process.username()** - [原文](https://psutil.readthedocs.io/en/latest/#psutil.Process.username) <a name="Process.username" ></a>

返回拥有当前进程的用户名。 在 UNIX 上，这是通过使用真实进程 uid 来计算的。

#### **用户ID**

**Process.uids()** - [原文](https://psutil.readthedocs.io/en/latest/#psutil.Process.uids) <a name="Process.uids" ></a>

返回一个由 (ruid, euid, suid) 所组成的元组，分别表示当前进程的真实用户ID，有效用户ID和暂存用户ID。这与 [os.getresuid][os.getresuid] 相同，但可用于任何进程 PID。

[os.getresuid]: https://docs.python.org/zh-cn/3/library/os.html#os.getresuid "os.getresuid"

译注例子:

```python
>>> psutil.Process().uids()
puids(real=501, effective=501, saved=501)
```

*可用平台: UNIX。*

#### **组ID**

**Process.gids()** - [原文](https://psutil.readthedocs.io/en/latest/#psutil.Process.gids) <a name="Process.gids" ></a>

返回一个由 (rgid, egid, sgid) 所组成的元组，分别表示当前进程的真实组ID，有效组ID和暂存组ID。这与 [os.getresgid][os.getresgid] 相同，但可用于任何进程 PID。

[os.getresgid]: https://docs.python.org/zh-cn/3/library/os.html#os.getresgid "os.getresgid"

*可用平台: UNIX。*

#### **终端**

**Process.terminal()** - [原文](https://psutil.readthedocs.io/en/latest/#psutil.Process.terminal) <a name="Process.terminal" ></a>

与此进程关联的终端（如果有），否则为 `None`。 类似于“`tty`”命令，但可用于任何进程PID。

*可用平台: UNIX。*

#### **优先级**

**Process.nice(value=None)** - [原文](https://psutil.readthedocs.io/en/latest/#psutil.Process.nice) <a name="Process.nice" ></a>

获取或设置进程良好度（优先级）。 在 UNIX 上，这是一个数字，通常从 `-20` 到 `20` 。nice 值越高，进程的优先级越低。

```python
>>> import psutil
>>> p = psutil.Process()
>>> p.nice(10)  # set
>>> p.nice()  # get
10
>>>
```

从 Python 3.3 开始，此功能类似于 [os.getpriority][os.getpriority] 和 [os.setpriority][os.setpriority]（参见 [BPO-10784][BPO-10784]）。 在 Windows 上，这是通过 Windows API 的 [GetPriorityClass][GetPriorityClass] 和 [SetPriorityClass][SetPriorityClass] 实现的，***value*** 是 [psutil.*_PRIORITY_CLASS](#process-priority-constant) 常量之一， 对应于MSDN文档。 在 Windows 上增加进程优先级的示例如下：

[os.getpriority]: https://docs.python.org/zh-cn/3/library/os.html#os.getpriority  "os.getpriority"
[os.setpriority]: https://docs.python.org/zh-cn/3/library/os.html#os.setpriority "os.setpriority"
[BPO-10784]: https://bugs.python.org/issue10784  "BPO-10784"
[GetPriorityClass]: https://docs.microsoft.com/zh-cn/windows/desktop/api/processthreadsapi/nf-processthreadsapi-getpriorityclass ""
[SetPriorityClass]: https://docs.microsoft.com/zh-cn/windows/desktop/api/processthreadsapi/nf-processthreadsapi-setpriorityclass ""

```python
>>> p.nice(psutil.HIGH_PRIORITY_CLASS)
```

#### **I/O优先级**

**Process.ionice(ioclass=None, value=None)** - [原文](https://psutil.readthedocs.io/en/latest/#psutil.Process.ionice) <a name="Process.ionice" ></a>

获取或设置进程的I/O良好度(优先级)。如果没有提供参数，它作为一个 get，在 Linux 上返回一个 `(ioclass, value)` 元组，在 Windows 上返回一个 ***ioclass*** 整数。如果提供了 ***ioclass*** ，它将作为一个集合。 在这种情况下，只能在 Linux 上指定一个附加值(***value***)，以便进一步提高或降低 I/O 优先级。下面是与平台相关的 ***ioclass*** 值。

Linux (参阅 [ioprio_get][ioprio_get]手册):

[ioprio_get]: https://linux.die.net/man/2/ioprio_get  "获取I/O优先级值手册"

* `IOPRIO_CLASS_RT`: (高) 该进程每次都首先访问磁盘。 小心使用它，因为它会使整个系统挨饿。 可以指定额外的优先级，范围从 `0`（最高）到 `7`（最低）。
* `IOPRIO_CLASS_BE`: (一般) 未设置特定 I/O 优先级的任何进程的默认值。 附加优先级范围从 `0`（最高）到 `7`（最低）。
* `IOPRIO_CLASS_IDLE`: (低) 在没有其他人需要磁盘时获取 I/O 时间。 不接受任何附加价值。
* `IOPRIO_CLASS_NONE`: 先前未设置优先级时返回。

Windows:

* `IOPRIO_HIGH`: 最高优先级.
* `IOPRIO_NORMAL`: 默认优先级.
* `IOPRIO_LOW`: 低优先级.
* `IOPRIO_VERYLOW`: 最低优先级.

下面是一个关于如何根据您使用的平台设置最高 I/O 优先级的示例：

```python
>>> import psutil
>>> p = psutil.Process()
>>> if psutil.LINUX:
...     p.ionice(psutil.IOPRIO_CLASS_RT, value=7)
... else:
...     p.ionice(psutil.IOPRIO_HIGH)
...
>>> p.ionice()  # get
pionice(ioclass=<IOPriority.IOPRIO_CLASS_RT: 1>, value=7)
```

*可用平台: Linux, Windows Vista+ 。*

*5.6.2 版本中修改: Windows 接受新的 `IOPRIO_*` 常量，包括新的 `IOPRIO_HIGH`。*

#### **资源限制**

**Process.rlimit(resource, limits=None)** - [原文](https://psutil.readthedocs.io/en/latest/#psutil.Process.rlimit) <a name="Process.rlimit" ></a>

Get or set process resource limits (see man prlimit). resource is one of the psutil.RLIMIT_* constants. limits is a (soft, hard) tuple. This is the same as resource.getrlimit and resource.setrlimit but can be used for any process PID, not only os.getpid. For get, return value is a (soft, hard) tuple. Each value may be either and integer or psutil.RLIMIT_*. Example:

```python
>>> import psutil
>>> p = psutil.Process()
>>> p.rlimit(psutil.RLIMIT_NOFILE, (128, 128))   # process can open max 128 file descriptors
>>> p.rlimit(psutil.RLIMIT_FSIZE, (1024, 1024))  # can create files no bigger than 1024 bytes
>>> p.rlimit(psutil.RLIMIT_FSIZE)                # get
(1024, 1024)
>>>
```

Also see procinfo.py script.

可用平台: Linux, FreeBSD

5.7.3 版本中修改: added FreeBSD support

**Process.io_counters()** - [原文](https://psutil.readthedocs.io/en/latest/#psutil.Process.io_counters) <a name="Process.io_counters" ></a>

Return process I/O statistics as a named tuple. For Linux you can refer to /proc filesystem documentation.

* `read_count`: the number of read operations performed (cumulative). This is supposed to count the number of read-related syscalls such as read() and pread() on UNIX.
* `write_count`: the number of write operations performed (cumulative). This is supposed to count the number of write-related syscalls such as write() and pwrite() on UNIX.
* `read_bytes`: the number of bytes read (cumulative). Always -1 on BSD.
* `write_bytes`: the number of bytes written (cumulative). Always -1 on BSD.
  Linux specific:
* `read_chars` (Linux): the amount of bytes which this process passed to read() and pread() syscalls (cumulative). Differently from read_bytes it doesn’t care whether or not actual physical disk I/O occurred.
* `write_chars` (Linux): the amount of bytes which this process passed to write() and pwrite() syscalls (cumulative). Differently from write_bytes it doesn’t care whether or not actual physical disk I/O occurred.
  Windows specific:
* `other_count` (Windows): the number of I/O operations performed other than read and write operations.
* `other_bytes` (Windows): the number of bytes transferred during operations other than read and write operations.\

```python
>>> import psutil
>>> p = psutil.Process()
>>> p.io_counters()
pio(read_count=454556, write_count=3456, read_bytes=110592, write_bytes=0, read_chars=769931, write_chars=203)
```

可用平台: Linux, BSD, Windows, AIX

5.2.0 版本中修改: added read_chars and write_chars on Linux; added other_count and other_bytes on Windows.

**Process.num_ctx_switches()** - [原文](https://psutil.readthedocs.io/en/latest/#psutil.Process.num_ctx_switches) <a name="Process.num_ctx_switches" ></a>

The number voluntary and involuntary context switches performed by this process (cumulative).

5.4.1 版本中修改: added AIX support

**Process.num_fds()** - [原文](https://psutil.readthedocs.io/en/latest/#psutil.Process.num_fds) <a name="Process.num_fds" ></a>

The number of file descriptors currently opened by this process (non cumulative).

可用平台: UNIX

**Process.num_handles()** - [原文](https://psutil.readthedocs.io/en/latest/#psutil.Process.num_handles) <a name="Process.num_handles" ></a>

The number of handles currently used by this process (non cumulative).

可用平台: Windows

**Process.num_threads()** - [原文](https://psutil.readthedocs.io/en/latest/#psutil.Process.num_threads) <a name="Process.num_threads" ></a>

The number of threads currently used by this process (non cumulative).

**Process.threads()** - [原文](https://psutil.readthedocs.io/en/latest/#psutil.Process.threads) <a name="Process.threads" ></a>

Return threads opened by process as a list of named tuples. On OpenBSD this method requires root privileges.

* `id`: the native thread ID assigned by the kernel. If pid refers to the current process, this matches the native_id attribute of the threading.Thread class, and can be used to reference individual Python threads running within your own Python app.
* `user_time`: time spent in user mode.
* `system_time`: time spent in kernel mode.

**Process.cpu_times()** - [原文](https://psutil.readthedocs.io/en/latest/#psutil.Process.cpu_times) <a name="Process.cpu_times" ></a>

Return a named tuple representing the accumulated process times, in seconds (see explanation). This is similar to os.times but can be used for any process PID.

* `user`: time spent in user mode.
* `system`: time spent in kernel mode.
* `children_user`: user time of all child processes (always 0 on Windows and macOS).
* `children_system`: system time of all child processes (always 0 on Windows and macOS).
* `iowait`: (Linux) time spent waiting for blocking I/O to complete. This value is excluded from user and system times count (because the CPU is not doing any work).

```python
>>> import psutil
>>> p = psutil.Process()
>>> p.cpu_times()
pcputimes(user=0.03, system=0.67, children_user=0.0, children_system=0.0, iowait=0.08)
>>> sum(p.cpu_times()[:2])  # cumulative, excluding children and iowait
0.70
```

4.1.0 版本中修改: return two extra fields: children_user and children_system.

5.6.4 版本中修改: added iowait on Linux.

**Process.cpu_percent(interval=None)** - [原文](https://psutil.readthedocs.io/en/latest/#psutil.Process.cpu_percent) <a name="Process.cpu_percent" ></a>

Return a float representing the process CPU utilization as a percentage which can also be > 100.0 in case of a process running multiple threads on different CPUs. When interval is > 0.0 compares process times to system CPU times elapsed before and after the interval (blocking). When interval is 0.0 or None compares process times to system CPU times elapsed since last call, returning immediately. That means the first time this is called it will return a meaningless 0.0 value which you are supposed to ignore. In this case is recommended for accuracy that this function be called a second time with at least 0.1 seconds between calls.

Example:

```python
>>> import psutil
>>> p = psutil.Process()
>>> # blocking
>>> p.cpu_percent(interval=1)
2.0
>>> # non-blocking (percentage since last call)
>>> p.cpu_percent(interval=None)
2.9
```

`注意`: the returned value can be > 100.0 in case of a process running multiple threads on different CPU cores.

`注意`: the returned value is explicitly not split evenly between all available CPUs (differently from psutil.cpu_percent()). This means that a busy loop process running on a system with 2 logical CPUs will be reported as having 100% CPU utilization instead of 50%. This was done in order to be consistent with top UNIX utility and also to make it easier to identify processes hogging CPU resources independently from the number of CPUs. It must be noted that taskmgr.exe on Windows does not behave like this (it would report 50% usage instead). To emulate Windows taskmgr.exe behavior you can do: p.cpu_percent() / psutil.cpu_count().

`警告`: the first time this method is called with interval = 0.0 or None it will return a meaningless 0.0 value which you are supposed to ignore.

**Process.cpu_affinity(cpus=None)** - [原文](https://psutil.readthedocs.io/en/latest/#psutil.Process.cpu_affinity) <a name="Process.cpu_affinity" ></a>

Get or set process current CPU affinity. CPU affinity consists in telling the OS to run a process on a limited set of CPUs only (on Linux cmdline, taskset command is typically used). If no argument is passed it returns the current CPU affinity as a list of integers. If passed it must be a list of integers specifying the new CPUs affinity. If an empty list is passed all eligible CPUs are assumed (and set). On some systems such as Linux this may not necessarily mean all available logical CPUs as in `list(range(psutil.cpu_count())))`.

```python
>>> import psutil
>>> psutil.cpu_count()
4
>>> p = psutil.Process()
>>> # get
>>> p.cpu_affinity()
[0, 1, 2, 3]
>>> # set; from now on, process will run on CPU #0 and #1 only
>>> p.cpu_affinity([0, 1])
>>> p.cpu_affinity()
[0, 1]
>>> # reset affinity against all eligible CPUs
>>> p.cpu_affinity([])
```

可用平台: Linux, Windows, FreeBSD

2.2.0 版本中修改: added support for FreeBSD

5.1.0 版本中修改: an empty list can be passed to set affinity against all eligible CPUs.

**Process.cpu_num()** - [原文](https://psutil.readthedocs.io/en/latest/#psutil.Process.cpu_num) <a name="Process.cpu_num" ></a>

Return what CPU this process is currently running on. The returned number should be <= psutil.cpu_count(). On FreeBSD certain kernel process may return -1. It may be used in conjunction with psutil.cpu_percent(percpu=True) to observe the system workload distributed across multiple CPUs as shown by cpu_distribution.py example script.

可用平台: Linux, FreeBSD, SunOS

5.1.0 版本中新增.

**Process.memory_info()** - [原文](https://psutil.readthedocs.io/en/latest/#psutil.Process.memory_info) <a name="Process.memory_info" ></a>
Return a named tuple with variable fields depending on the platform representing memory information about the process. The “portable” fields available on all plaforms are rss and vms. All numbers are expressed in bytes.

| Linux  | macOS   | BSD   | Solaris | AIX | Windows                    |
| ------ | ------- | ----- | ------- | --- | -------------------------- |
| rss    | rss     | rss   | rss     | rss | rss(alias for `wset`)      |
| vms    | vms     | vms   | vms     | vms | vms (alias for `pagefile`) |
| shared | pfaults | text  | -       | -   | num_page_faults            |
| text   | pageins | data  | -       | -   | peak_wset                  |
| lib    | -       | stack | -       | -   | wset                       |
| data   | -       | -     | -       | -   | peak_paged_pool            |
| dirty  | -       | -     | -       | -   | paged_pool                 |
| -      | -       | -     | -       | -   | peak_nonpaged_pool         |
| -      | -       | -     | -       | -   | nonpaged_pool              |
| -      | -       | -     | -       | -   | pagefile                   |
| -      | -       | -     | -       | -   | peak_pagefile              |
| -      | -       | -     | -       | -   | private                    |

* `rss`: aka “Resident Set Size”, this is the non-swapped physical memory a process has used. On UNIX it matches “top“‘s RES column). On Windows this is an alias for wset field and it matches “Mem Usage” column of taskmgr.exe.
* `vms`: aka “Virtual Memory Size”, this is the total amount of virtual memory used by the process. On UNIX it matches “top“‘s VIRT column. On Windows this is an alias for pagefile field and it matches “Mem Usage” “VM Size” column of taskmgr.exe.
* `shared`: (Linux) memory that could be potentially shared with other processes. This matches “top“‘s SHR column).
* `text` (Linux, BSD): aka TRS (text resident set) the amount of memory devoted to executable code. This matches “top“‘s CODE column).
* `data` (Linux, BSD): aka DRS (data resident set) the amount of physical memory devoted to other than executable code. It matches “top“‘s DATA column).
* `lib` (Linux): the memory used by shared libraries.
* `dirty` (Linux): the number of dirty pages.
* `pfaults` (macOS): number of page faults.
* `pageins` (macOS): number of actual pageins.

For on explanation of Windows fields rely on PROCESS_MEMORY_COUNTERS_EX structure doc. Example on Linux:

```python
>>> import psutil
>>> p = psutil.Process()
>>> p.memory_info()
pmem(rss=15491072, vms=84025344, shared=5206016, text=2555904, lib=0, data=9891840, dirty=0)
```

4.0.0 版本中修改: multiple fields are returned, not only rss and vms.

**Process.memory_info_ex()** - [原文](https://psutil.readthedocs.io/en/latest/#psutil.Process.memory_info_ex) <a name="Process.memory_info_ex" ></a>

Same as [memory_info()](#Process.memory_info_ex) (deprecated).

**注意**: Warning deprecated in version 4.0.0; use memory_info() instead.

**Process.memory_full_info()** - [原文](https://psutil.readthedocs.io/en/latest/#psutil.Process.memory_full_info) <a name="Process.memory_full_info" ></a>

This method returns the same information as memory_info(), plus, on some platform (Linux, macOS, Windows), also provides additional metrics (USS, PSS and swap). The additional metrics provide a better representation of “effective” process memory consumption (in case of USS) as explained in detail in this blog post. It does so by passing through the whole process address. As such it usually requires higher user privileges than memory_info() and is considerably slower. On platforms where extra fields are not implemented this simply returns the same metrics as memory_info().

* `uss` (Linux, macOS, Windows): aka “Unique Set Size”, this is the memory which is unique to a process and which would be freed if the process was terminated right now.
* `pss` (Linux): aka “Proportional Set Size”, is the amount of memory shared with other processes, accounted in a way that the amount is divided evenly between the processes that share it. I.e. if a process has 10 MBs all to itself and 10 MBs shared with another process its PSS will be 15 MBs.
* `swap` (Linux): amount of memory that has been swapped out to disk.

Note uss is probably the most representative metric for determining how much memory is actually being used by a process. It represents the amount of memory that would be freed if the process was terminated right now.

Example on Linux:

```python
>>> import psutil
>>> p = psutil.Process()
>>> p.memory_full_info()
pfullmem(rss=10199040, vms=52133888, shared=3887104, text=2867200, lib=0, data=5967872, dirty=0, uss=6545408, pss=6872064, swap=0)
>>>
```

See also procsmem.py for an example application.

4.0.0 版本中新增.

**Process.memory_percent(memtype="rss")** - [原文](https://psutil.readthedocs.io/en/latest/#psutil.Process.memory_percent) <a name="Process.memory_percent" ></a>

Compare process memory to total physical system memory and calculate process memory utilization as a percentage. memtype argument is a string that dictates what type of process memory you want to compare against. You can choose between the named tuple field names returned by memory_info() and memory_full_info() (defaults to "rss").

4.0.0 版本中修改: added memtype parameter.

**Process.memory_maps(grouped=True)** - [原文](https://psutil.readthedocs.io/en/latest/#psutil.Process.memory_maps) <a name="Process.memory_maps" ></a>
Return process’s mapped memory regions as a list of named tuples whose fields are variable depending on the platform. This method is useful to obtain a detailed representation of process memory usage as explained here (the most important value is “private” memory). If grouped is True the mapped regions with the same path are grouped together and the different memory fields are summed. If grouped is False each mapped region is shown as a single entity and the named tuple will also include the mapped region’s address space (addr) and permission set (perms). See pmap.py for an example application.

| Linux         | Windows | FreeBSD      | Solaris   |
| ------------- | ------- | ------------ | --------- |
| rss           | rss     | rss          | rss       |
| size          | -       | private      | anonymous |
| pss           | -       | ref_count    | locked    |
| shared_clean  | -       | shadow_count | -         |
| shared_dirty  | -       | -            | -         |
| private_clean | -       | -            | -         |
| private_dirty | -       | -            | -         |
| referenced    | -       | -            | -         |
| anonymous     | -       | -            | -         |
| swap          | -       | -            | -         |

```python
>>> import psutil
>>> p = psutil.Process()
>>> p.memory_maps()
[pmmap_grouped(path='/lib/x8664-linux-gnu/libutil-2.15.so', rss=32768, size=2125824, pss=32768, shared_clean=0, shared_dirty=0, private_clean=20480, private_dirty=12288, referenced=32768, anonymous=12288, swap=0),
pmmap_grouped(path='/lib/x8664-linux-gnu/libc-2.15.so', rss=3821568, size=3842048, pss=3821568, shared_clean=0, shared_dirty=0, private_clean=0, private_dirty=3821568, referenced=3575808, anonymous=3821568, swap=0),
...]
```

可用平台: Linux, Windows, FreeBSD, SunOS

5.6.0 版本中修改: removed macOS support because inherently broken (see issue #1291)

**Process.children(recursive=False)** - [原文](https://psutil.readthedocs.io/en/latest/#psutil.Process.children) <a name="Process.children" ></a>
Return the children of this process as a list of Process instances. If recursive is True return all the parent descendants. Pseudo code example assuming A == this process:

```python
  A ─┐
    │
    ├─ B (child) ─┐
    │             └─ X (grandchild) ─┐
    │                                └─ Y (great grandchild)
    ├─ C (child)
    └─ D (child)

>>> p.children()
B, C, D
>>> p.children(recursive=True)
B, X, Y, C, D
```

Note that in the example above if process X disappears process Y won’t be returned either as the reference to process A is lost. This concept is well summaried by this unit test. See also how to kill a process tree and terminate my children.

**Process.open_files()** - [原文](https://psutil.readthedocs.io/en/latest/#psutil.Process.open_files) <a name="Process.open_files" ></a>

Return regular files opened by process as a list of named tuples including the following fields:

* `path`: the absolute file name.
* `fd`: the file descriptor number; on Windows this is always -1.

Linux only:

* `position` (Linux): the file (offset) position.
* `mode` (Linux): a string indicating how the file was opened, similarly to open builtin mode argument. Possible values are 'r', 'w', 'a', 'r+' and 'a+'. There’s no distinction between files opened in binary or text mode ("b" or "t").
* `flags` (Linux): the flags which were passed to the underlying os.open C call when the file was opened (e.g. os.O_RDONLY, os.O_TRUNC, etc).

```python
>>> import psutil
>>> f = open('file.ext', 'w')
>>> p = psutil.Process()
>>> p.open_files()
[popenfile(path='/home/giampaolo/svn/psutil/file.ext', fd=3, position=0, mode='w', flags=32769)]
```

**Warning** on Windows this method is not reliable due to some limitations of the underlying Windows API which may hang when retrieving certain file handles. In order to work around that psutil spawns a thread to determine the file handle name and kills it if it’s not responding after 100ms. That implies that this method on Windows is not guaranteed to enumerate all regular file handles (see issue 597). Tools like ProcessHacker has the same limitation.

**Warning** on BSD this method can return files with a null path (“”) due to a kernel bug, hence it’s not reliable (see issue 595).

3.1.0 版本中修改: no longer hangs on Windows.

4.1.0 版本中修改: new position, mode and flags fields on Linux.

**Process.connections(kind="inet")** - [原文](https://psutil.readthedocs.io/en/latest/#psutil.Process.connections) <a name="Process.connections" ></a>

Return socket connections opened by process as a list of named tuples. To get system-wide connections use psutil.net_connections(). Every named tuple provides 6 attributes:

* `fd`: the socket file descriptor. This can be passed to socket.fromfd to obtain a usable socket object. On Windows, FreeBSD and SunOS this is always set to -1.
* `family`: the address family, either AF_INET, AF_INET6 or AF_UNIX.
* `type`: the address type, either SOCK_STREAM, SOCK_DGRAM or SOCK_SEQPACKET. .
* `laddr`: the local address as a (ip, port) named tuple or a path in case of AF_UNIX sockets. For UNIX sockets see notes below.
* `raddr`: the remote address as a (ip, port) named tuple or an absolute path in case of UNIX sockets. When the remote endpoint is not connected you’ll get an empty tuple (AF_INET*) or "" (AF_UNIX). For UNIX sockets see notes below.
* `status`: represents the status of a TCP connection. The return value is one of the psutil.CONN_* constants. For UDP and UNIX sockets this is always going to be psutil.CONN_NONE.

The kind parameter is a string which filters for connections that fit the following criteria:

| Kind value | Connections using                                  |
| ---------- | -------------------------------------------------- |
| `"inet"`   | IPv4 and IPv6                                      |
| `"inet4"`  | IPv4                                               |
| `"inet6"`  | IPv6                                               |
| `"tcp"`    | TCP                                                |
| `"tcp4"`   | TCP over IPv4                                      |
| `"tcp6"`   | TCP over IPv6                                      |
| `"udp"`    | UDP                                                |
| `"udp4"`   | UDP over IPv4                                      |
| `"udp6"`   | UDP over IPv6                                      |
| `"unix"`   | UNIX socket (both UDP and TCP protocols)           |
| `"all"`    | the sum of all the possible families and protocols |

Example:

```python
>>> import psutil
>>> p = psutil.Process(1694)
>>> p.name()
'firefox'
>>> p.connections()
[pconn(fd=115, family=<AddressFamily.AF_INET: 2>, type=<SocketType.SOCK_STREAM: 1>, laddr=addr(ip='10.0.0.1', port=48776), raddr=addr(ip='93.186.135.91', port=80), status='ESTABLISHED'),
pconn(fd=117, family=<AddressFamily.AF_INET: 2>, type=<SocketType.SOCK_STREAM: 1>, laddr=addr(ip='10.0.0.1', port=43761), raddr=addr(ip='72.14.234.100', port=80), status='CLOSING'),
pconn(fd=119, family=<AddressFamily.AF_INET: 2>, type=<SocketType.SOCK_STREAM: 1>, laddr=addr(ip='10.0.0.1', port=60759), raddr=addr(ip='72.14.234.104', port=80), status='ESTABLISHED'),
pconn(fd=123, family=<AddressFamily.AF_INET: 2>, type=<SocketType.SOCK_STREAM: 1>, laddr=addr(ip='10.0.0.1', port=51314), raddr=addr(ip='72.14.234.83', port=443), status='SYN_SENT')]
```

Note (Solaris) UNIX sockets are not supported.

Note (Linux, FreeBSD) “raddr” field for UNIX sockets is always set to “”. This is a limitation of the OS.

Note (OpenBSD) “laddr” and “raddr” fields for UNIX sockets are always set to “”. This is a limitation of the OS.

Note (AIX) psutil.AccessDenied is always raised unless running as root (lsof does the same).

5.3.0 版本中修改: : “laddr” and “raddr” are named tuples.

**Process.is_running()** - [原文](https://psutil.readthedocs.io/en/latest/#psutil.Process.is_running) <a name="Process.is_running" ></a>

Return whether the current process is running in the current process list. This is reliable also in case the process is gone and its PID reused by another process, therefore it must be preferred over doing `psutil.pid_exists(p.pid)`.

Note this will return `True` also if the process is a zombie (`p.status() == psutil.STATUS_ZOMBIE`).

**Process.send_signal(signal)** - [原文](https://psutil.readthedocs.io/en/latest/#psutil.Process.send_signal) <a name="Process.send_signal" ></a>

Send a signal to process (see signal module constants) preemptively checking whether PID has been reused. On UNIX this is the same as os.kill(pid, sig). On Windows only SIGTERM, CTRL_C_EVENT and CTRL_BREAK_EVENT signals are supported and SIGTERM is treated as an alias for kill(). See also how to kill a process tree and terminate my children.

3.2.0 版本中修改: support for CTRL_C_EVENT and CTRL_BREAK_EVENT signals on Windows was added.

**Process.suspend()** - [原文](https://psutil.readthedocs.io/en/latest/#psutil.Process.suspend) <a name="Process.suspend" ></a>
Suspend process execution with SIGSTOP signal preemptively checking whether PID has been reused. On UNIX this is the same as os.kill(pid, signal.SIGSTOP). On Windows this is done by suspending all process threads execution.

**Process.resume()** - [原文](https://psutil.readthedocs.io/en/latest/#psutil.Process.resume) <a name="Process.resume" ></a>
Resume process execution with SIGCONT signal preemptively checking whether PID has been reused. On UNIX this is the same as os.kill(pid, signal.SIGCONT). On Windows this is done by resuming all process threads execution.

**Process.terminate()** - [原文](https://psutil.readthedocs.io/en/latest/#psutil.Process.terminate) <a name="Process.terminate" ></a>
Terminate the process with SIGTERM signal preemptively checking whether PID has been reused. On UNIX this is the same as os.kill(pid, signal.SIGTERM). On Windows this is an alias for kill(). See also how to kill a process tree and terminate my children.

**Process.kill()** - [原文](https://psutil.readthedocs.io/en/latest/#psutil.Process.kill) <a name="Process.kill" ></a>
Kill the current process by using SIGKILL signal preemptively checking whether PID has been reused. On UNIX this is the same as os.kill(pid, signal.SIGKILL). On Windows this is done by using TerminateProcess. See also how to kill a process tree and terminate my children.

**Process.wait(timeout=None)** - [原文](https://psutil.readthedocs.io/en/latest/#psutil.Process.wait)  <a name="Process.wait" ></a>

Wait for a process PID to terminate. The details about the return value differ on UNIX and Windows.

On UNIX: if the process terminated normally, the return value is a positive integer >= 0 indicating the exit code. If the process was terminated by a signal return the negated value of the signal which caused the termination (e.g. -SIGTERM). If PID is not a children of os.getpid (current process) just wait until the process disappears and return None. If PID does not exist return None immediately.

On Windows: always return the exit code, which is a positive integer as returned by GetExitCodeProcess.

timeout is expressed in seconds. If specified and the process is still alive raise TimeoutExpired exception. timeout=0 can be used in non-blocking apps: it will either return immediately or raise TimeoutExpired.

The return value is cached. To wait for multiple processes use psutil.wait_procs().

```python
>>> import psutil
>>> p = psutil.Process(9891)
>>> p.terminate()
>>> p.wait()
<Negsignal.SIGTERM: -15>
```

5.7.1 版本中修改: return value is cached (instead of returning None).

5.7.1 版本中修改: on POSIX, in case of negative signal, return it as a human readable enum.

**`class` psutil.Popen(\*args, \*\*kwargs)** - [原文](https://psutil.readthedocs.io/en/latest/#psutil.Popen) <a name="Popen" ></a>

Same as subprocess.Popen but in addition it provides all psutil.Process methods in a single class. For the following methods which are common to both classes, psutil implementation takes precedence: send_signal(), terminate(), kill(). This is done in order to avoid killing another process in case its PID has been reused, fixing BPO-6973.

```python
>>> import psutil
>>> from subprocess import PIPE
>>>
>>> p = psutil.Popen(["/usr/bin/python", "-c", "print('hello')"], stdout=PIPE)
>>> p.name()
'python'
>>> p.username()
'giampaolo'
>>> p.communicate()
('hello\n', None)
>>> p.wait(timeout=2)
0
>>>
```
版本 4.4.0 中改变: 新增支持上下文管理

## **Windows 服务** (Windows services)

**psutil.win_service_iter()** - [原文](https://psutil.readthedocs.io/en/latest/#psutil.win_service_iter)

Return an iterator yielding a WindowsService class instance for all Windows services installed.

版本 4.2.0 中新增.

可用平台: Windows

**psutil.win_service_get(name)** - [原文](https://psutil.readthedocs.io/en/latest/#psutil.win_service_get)

Get a Windows service by name, returning a WindowsService instance. Raise psutil.NoSuchProcess if no service with such name exists.

版本 4.2.0 中新增.

可用平台: Windows

`class` **psutil.WindowsService** - [原文](https://psutil.readthedocs.io/en/latest/#psutil.WindowsService)

  Represents a Windows service with the given name. This class is returned by win_service_iter() and win_service_get() functions and it is not supposed to be instantiated directly.

  * `name`() - [原文](https://psutil.readthedocs.io/en/latest/#psutil.WindowsService.name)
    The service name. This string is how a service is referenced and can be passed to win_service_get() to get a new WindowsService instance.
  * `display_name`() - [原文](https://psutil.readthedocs.io/en/latest/#psutil.WindowsService.display_name)
    The service display name. The value is cached when this class is instantiated.
  * `binpath`() - [原文](https://psutil.readthedocs.io/en/latest/#psutil.WindowsService.binpath)
    The fully qualified path to the service binary/exe file as a string, including command line arguments.
  * `username`() - [原文](https://psutil.readthedocs.io/en/latest/#psutil.WindowsService.username)
    The name of the user that owns this service.
  * `start_type`() - [原文](https://psutil.readthedocs.io/en/latest/#psutil.WindowsService.start_type)
    A string which can either be “automatic”, “manual” or “disabled”.
  * `pid`() - [原文](https://psutil.readthedocs.io/en/latest/#psutil.WindowsService.pid)
    The process PID, if any, else None. This can be passed to Process class to control the service’s process.
  * `status`() - [原文](https://psutil.readthedocs.io/en/latest/#psutil.WindowsService.status)
    Service status as a string, which may be either “running”, “paused”, “start_pending”, “pause_pending”, “continue_pending”, “stop_pending” or “stopped”.
  * `description`() - [原文](https://psutil.readthedocs.io/en/latest/#psutil.WindowsService.description)
    Service long description.
  * `as_dict`()
    Utility method retrieving all the information above as a dictionary. - [原文](https://psutil.readthedocs.io/en/latest/#psutil.WindowsService.as_dict)

  版本 4.2.0 中新增.
  
  可用平台: Windows

  ```python
  >>> import psutil
  >>> list(psutil.win_service_iter())
  [<WindowsService(name='AeLookupSvc', display_name='Application Experience') at 38850096>,
  <WindowsService(name='ALG', display_name='Application Layer Gateway Service') at 38850128>,
  <WindowsService(name='APNMCP', display_name='Ask Update Service') at 38850160>,
  <WindowsService(name='AppIDSvc', display_name='Application Identity') at 38850192>,
  ...]
  >>> s = psutil.win_service_get('alg')
  >>> s.as_dict()
  {'binpath': 'C:\\Windows\\System32\\alg.exe',
  'description': 'Provides support for 3rd party protocol plug-ins for Internet Connection Sharing',
  'display_name': 'Application Layer Gateway Service',
  'name': 'alg',
  'pid': None,
  'start_type': 'manual',
  'status': 'stopped',
  'username': 'NT AUTHORITY\\LocalService'}
  ```

## **常量** (Constants)

### **操作系统**

参考: [原文](https://psutil.readthedocs.io/en/latest/#operating-system-constants)

* psutil.**POSIX**
* psutil.**LINUX**
* psutil.**WINDOWS**
* psutil.**MACOS**
* psutil.**FREEBSD**
* psutil.**NETBSD**
* psutil.**OPENBSD**
* psutil.**BSD**
* psutil.**SUNOS**
* psutil.**AIX**
  `bool` 常量, 该常量定义了你属于什么平台. 例如: 如果在Windows平台, **WINDOWS** 常量将会为 `True`, 其他平台将会为 `False`.
  版本 4.0.0. 中新增
  版本 5.4.0 中改变过: 新增 AIX

* psutil.**OSX**
  **MACOS** 的别名.
  **注意**: 版本 5.4.7 中已弃用; 使用 **MACOS** 替换.
  
* psutil.**PROCFS_PATH**
  The path of the /proc filesystem on Linux, Solaris and AIX (defaults to "/proc"). You may want to re-set this constant right after importing psutil in case your /proc filesystem is mounted elsewhere or if you want to retrieve information about Linux containers such as Docker, Heroku or LXC (see here for more info). It must be noted that this trick works only for APIs which rely on /proc filesystem (e.g. memory APIs and most Process class methods).
  可用平台: Linux, Solaris, AIX
  3.2.3 版本中新增.
  3.4.2 版本中修改: also available on Solaris.
  5.4.0 版本中修改: also available on AIX.

### **进程状态** (Process status constants) <a name="process-status-constant"></a>

参考: [原文](https://psutil.readthedocs.io/en/latest/#process-status-constants)

* psutil.**STATUS_RUNNING**
* psutil.**STATUS_SLEEPING**
* psutil.**STATUS_DISK_SLEEP**
* psutil.**STATUS_STOPPED**
* psutil.**STATUS_TRACING_STOP**
* psutil.**STATUS_ZOMBIE**
* psutil.**STATUS_DEAD**
* psutil.**STATUS_WAKE_KILL**
* psutil.**STATUS_WAKING**
* psutil.**STATUS_PARKED)**(_Linux_)
* psutil.**STATUS_IDLE)**(_Linux_, _macOS_, _FreeBSD_)
* psutil.**STATUS_LOCKED)**(_FreeBSD_)
* psutil.**STATUS_WAITING)**(_FreeBSD_)
* psutil.**STATUS_SUSPENDED)**(_NetBSD_
  Represent a process status. Returned by psutil.Process.status().
  3.4.1 版本中新增: STATUS_SUSPENDED (NetBSD)
  5.4.7 版本中新增: STATUS_PARKED (Linux)

### **进程优先级** (Process priority constants) <a name="process-priority-constant"></a>

参考: [原文](https://psutil.readthedocs.io/en/latest/#process-priority-constants)

* psutil.**REALTIME_PRIORITY_CLASS**
* psutil.**HIGH_PRIORITY_CLASS**
* psutil.**ABOVE_NORMAL_PRIORITY_CLASS**
* psutil.**ABOVE_NORMAL_PRIORITY_CLASS**
* psutil.**NORMAL_PRIORITY_CLASS**
* psutil.**IDLE_PRIORITY_CLASS**
* psutil.**BELOW_NORMAL_PRIORITY_CLASS**
  Represent the priority of a process on Windows (see SetPriorityClass). They can be used in conjunction with psutil.Process.nice() to get or set process priority.
  可用平台: Windows
* psutil.**IOPRIO_CLASS_NONE**
* psutil.**IOPRIO_CLASS_RT**
* psutil.**IOPRIO_CLASS_BE**
* psutil.**IOPRIO_CLASS_IDLE**
  A set of integers representing the I/O priority of a process on Linux. They can be used in conjunction with psutil.Process.ionice() to get or set process I/O priority. IOPRIO_CLASS_NONE and IOPRIO_CLASS_BE (best effort) is the default for any process that hasn’t set a specific I/O priority. IOPRIO_CLASS_RT (real time) means the process is given first access to the disk, regardless of what else is going on in the system. IOPRIO_CLASS_IDLE means the process will get I/O time when no-one else needs the disk. For further information refer to manuals of ionice command line utility or ioprio_get system call.
  可用平台: Linux
* psutil.**IOPRIO_VERYLOW**
* psutil.**IOPRIO_LOW**
* psutil.**IOPRIO_NORMAL**
* psutil.**IOPRIO_HIGH**
  A set of integers representing the I/O priority of a process on Windows. They can be used in conjunction with psutil.Process.ionice() to get or set process I/O priority.
  可用平台: Windows
  5.6.2 版本中新增.

### **进程资源** (Process resources constants)

参考: [原文](https://psutil.readthedocs.io/en/latest/#process-resources-constants)

* **Linux** / **FreeBSD**:
  * psutil.**RLIM_INFINITY**
  * psutil.**RLIMIT_AS**
  * psutil.**RLIMIT_CORE**
  * psutil.**RLIMIT_CPU**
  * psutil.**RLIMIT_DATA**
  * psutil.**RLIMIT_FSIZE**
  * psutil.**RLIMIT_MEMLOCK**
  * psutil.**RLIMIT_NOFILE**
  * psutil.**RLIMIT_NPROC**
  * psutil.**RLIMIT_RSS**
  * psutil.**RLIMIT_STACK**
* Linux specific:
  * psutil.**RLIMIT_LOCKS**
  * psutil.**RLIMIT_MSGQUEUE**
  * psutil.**RLIMIT_NICE**
  * psutil.**RLIMIT_RTPRIO**
  * psutil.**RLIMIT_RTTIME**
  * psutil.**RLIMIT_SIGPENDING**
* FreeBSD specific:
  * psutil.**RLIMIT_SWAP**
  * psutil.**RLIMIT_SBSIZE**
  * psutil.**RLIMIT_NPTS**

Constants used for getting and setting process resource limits to be used in conjunction with psutil.Process.rlimit(). See resource.getrlimit for further information.

可用平台: Linux, FreeBSD

5.7.3 版本中修改: added FreeBSD support, added RLIMIT_SWAP, RLIMIT_SBSIZE, RLIMIT_NPTS.

### **网络连接** (Connections constants)

参考: [原文](https://psutil.readthedocs.io/en/latest/#connections-constants)

* psutil.**CONN_ESTABLISHED**
* psutil.**CONN_SYN_SENT**
* psutil.**CONN_SYN_RECV**
* psutil.**CONN_FIN_WAIT1**
* psutil.**CONN_FIN_WAIT2**
* psutil.**CONN_TIME_WAIT**
* psutil.**CONN_CLOSE**
* psutil.**CONN_CLOSE_WAIT**
* psutil.**CONN_LAST_ACK**
* psutil.**CONN_LISTEN**
* psutil.**CONN_CLOSING**
* psutil.**CONN_NONE**
* psutil.**CONN_DELETE_TCB**(_Windows_)
* psutil.**CONN_IDLE**(_Solaris_)
* psutil.**CONN_BOUND**(_Solaris_)
  A set of strings representing the status of a TCP connection. Returned by psutil.Process.connections() and psutil.net_connections() (status field).

### **硬件** (Hardware constants)

参考: [原文](https://psutil.readthedocs.io/en/latest/#hardware-constants)

* AF_LINK <a name="psutil.AF_LINK"></a>
  Constant which identifies a MAC address associated with a network interface. To be used in conjunction with psutil.net_if_addrs().
  3.0.0 版本中新增.
* NIC_DUPLEX_FULL <a name="psutil.NIC_DUPLEX_FULL"></a>
* NIC_DUPLEX_HALF <a name="psutil.NIC_DUPLEX_HALF"></a>
* NIC_DUPLEX_UNKNOWN <a name="psutil.NIC_DUPLEX_UNKNOWN"></a>
  Constants which identifies whether a NIC (network interface card) has full or half mode speed. NIC_DUPLEX_FULL means the NIC is able to send and receive data (files) simultaneously, NIC_DUPLEX_FULL means the NIC can either send or receive data at a time. To be used in conjunction with psutil.net_if_stats().
  3.0.0 版本中新增.
* POWER_TIME_UNKNOWN <a name="psutil.POWER_TIME_UNKNOWN">
* POWER_TIME_UNLIMITED <a name="psutil.POWER_TIME_UNLIMITED">
  Whether the remaining time of the battery cannot be determined or is unlimited. May be assigned to psutil.sensors_battery()’s secsleft field.
  5.1.0 版本中新增.
* version_info
  A tuple to check psutil installed version. Example:
  ```python
  >>> import psutil
  >>> if psutil.version_info >= (4, 5):
  ...    pass
  ```

## **工具函数** (Recipes)

### **按名称查找进程** (Find process by name) <a name="find-process-by-name"></a>

参考: [原文](https://psutil.readthedocs.io/en/latest/#find-process-by-name)

Check string against `Process.name()`:

```python
import psutil

def find_procs_by_name(name):
    "Return a list of processes matching 'name'."
    ls = []
    for p in psutil.process_iter(['name']):
        if p.info['name'] == name:
            ls.append(p)
    return ls
```

A bit more advanced, check string against Process.name(), Process.exe() and Process.cmdline():

```python
import os
import psutil

def find_procs_by_name(name):
    "Return a list of processes matching 'name'."
    ls = []
    for p in psutil.process_iter(["name", "exe", "cmdline"]):
        if name == p.info['name'] or \
                p.info['exe'] and os.path.basename(p.info['exe']) == name or \
                p.info['cmdline'] and p.info['cmdline'][0] == name:
            ls.append(p)
    return ls
```

### **kill进程树** (Kill process tree)

参考: [原文](https://psutil.readthedocs.io/en/latest/#kill-process-tree)

```python
import os
import signal
import psutil

def kill_proc_tree(pid, sig=signal.SIGTERM, include_parent=True,
                   timeout=None, on_terminate=None):
    """Kill a process tree (including grandchildren) with signal
    "sig" and return a (gone, still_alive) tuple.
    "on_terminate", if specified, is a callback function which is
    called as soon as a child terminates.
    """
    assert pid != os.getpid(), "won't kill myself"
    parent = psutil.Process(pid)
    children = parent.children(recursive=True)
    if include_parent:
        children.append(parent)
    for p in children:
        try:
            p.send_signal(sig)
        except psutil.NoSuchProcess:
            pass
    gone, alive = psutil.wait_procs(children, timeout=timeout,
                                    callback=on_terminate)
    return (gone, alive)
```

### **过滤和排序进程** (Filtering and sorting processes)

参考: [原文](https://psutil.readthedocs.io/en/latest/#filtering-and-sorting-processes)

这个代码样例合集将展示如果通过`process_iter()`函数去过滤和排序进程。开始:

```python
>>> import psutil
>>> from pprint import pprint as pp
```

当前用户拥有的进程:

```python
>>> import getpass
>>> pp([(p.pid, p.info['name']) for p in psutil.process_iter(['name', 'username']) if p.info['username'] == getpass.getuser()])
(16832, 'bash'),
(19772, 'ssh'),
(20492, 'python')]
```

正在运行的进程:

```python
>>> pp([(p.pid, p.info) for p in psutil.process_iter(['name', 'status']) if p.info['status'] == psutil.STATUS_RUNNING])
[(1150, {'name': 'Xorg', 'status': 'running'}),
 (1776, {'name': 'unity-panel-service', 'status': 'running'}),
 (20492, {'name': 'python', 'status': 'running'})]
```

使用log日志文件的进程:

```python
>>> for p in psutil.process_iter(['name', 'open_files']):
...      for file in p.info['open_files'] or []:
...          if file.path.endswith('.log'):
...               print("%-5s %-10s %s" % (p.pid, p.info['name'][:10], file.path))
...
1510  upstart    /home/giampaolo/.cache/upstart/unity-settings-daemon.log
2174  nautilus   /home/giampaolo/.local/share/gvfs-metadata/home-ce08efac.log
2650  chrome     /home/giampaolo/.config/google-chrome/Default/data_reduction_proxy_leveldb/000003.log
```

进程消耗超过500M的内存:

```python
>>> pp([(p.pid, p.info['name'], p.info['memory_info'].rss) for p in psutil.process_iter(['name', 'memory_info']) if p.info['memory_info'].rss > 500 * 1024 * 1024])
[(2650, 'chrome', 532324352),
 (3038, 'chrome', 1120088064),
 (21915, 'sublime_text', 615407616)]
```

Top 3 processes which consumed the most CPU time:

```python
>>> pp([(p.pid, p.info['name'], sum(p.info['cpu_times'])) for p in sorted(psutil.process_iter(['name', 'cpu_times']), key=lambda p: sum(p.info['cpu_times'][:2]))][-3:])
[(2721, 'chrome', 10219.73),
 (1150, 'Xorg', 11116.989999999998),
 (2650, 'chrome', 18451.97)]
```

### **字节转换** (Bytes conversion)

参考: [原文](https://psutil.readthedocs.io/en/latest/#bytes-conversion)

```python
import psutil

def bytes2human(n):
    # http://code.activestate.com/recipes/578019
    # >>> bytes2human(10000)
    # '9.8K'
    # >>> bytes2human(100001221)
    # '95.4M'
    symbols = ('K', 'M', 'G', 'T', 'P', 'E', 'Z', 'Y')
    prefix = {}
    for i, s in enumerate(symbols):
        prefix[s] = 1 << (i + 1) * 10
    for s in reversed(symbols):
        if n >= prefix[s]:
            value = float(n) / prefix[s]
            return '%.1f%s' % (value, s)
    return "%sB" % n

total = psutil.disk_usage('/').total
print(total)
print(bytes2human(total))
```

…prints:

```python
100399730688
93.5G
```

## **常见问题** (FAQs)

参考: [原文](https://psutil.readthedocs.io/en/latest/#faqs)

* Q: 为什么某些进程我会无权限?
* A: 当你查询其他用户拥有的进程时可能会发生这种情况，尤其是在 macOS (参考[问题 #883](https://github.com/giampaolo/psutil/issues/883)) 和 Windows 上。不幸的是，除了以更高的权限运行 Python 进程之外，您对此无能为力。 在 Unix 上，你可以以 root 身份运行 Python 进程或使用 SUID 位（ps 和 netstat 执行此操作）。 在 Windows 上，你可以将 Python 进程作为 NT AUTHORITY\SYSTEM 运行，或者将 Python 脚本安装为 Windows 服务（ProcessHacker 执行此操作）。
* Q: 支持在windows系统的MinGW上运行吗?
* A: 不支持, 你应该使用 Visual Studio (参阅 [开发指南](https://github.com/giampaolo/psutil/blob/master/docs/DEVGUIDE.rst)).

## **测试** (Running tests)

参考: [原文](https://psutil.readthedocs.io/en/latest/#running-tests)

```python
python3 -m psutil.tests
```

### debug模式 (Debug mode) - [原文](https://psutil.readthedocs.io/en/latest/#debug-mode)

如果想调试异常情况或报告一个漏洞，使用环境变量`PSUTIL_DEBUG`开启调试模式将会非常有用。在调试模式中，psutil会(或者不会)打印额外的信息到标准错误输出(stderr)。通常这些错误情况并不严重，因此常被忽略（防止崩溃）。在调试模式启动时单元测试是自动运行的。在Unix中：

```python
$ PSUTIL_DEBUG=1 python3 script.py
psutil-debug [psutil/_psutil_linux.c:150]> setmntent() failed (ignored)
```

在windows系统中:

```python
set PSUTIL_DEBUG=1 python.exe script.py
psutil-debug [psutil/arch/windows/process_info.c:90]> NtWow64ReadVirtualMemory64(pbi64.PebBaseAddress) -> 998 (Unknown error) (ignored)
```

## **安全** (Security)

参考: [原文](https://psutil.readthedocs.io/en/latest/#security)

在报告安全漏洞时, 请使用 [Tidelift 安全联系人](https://tidelift.com/security). Tidelift 将协调修复和披露。

## **开发指南** (Development guide)

参考: [原文](https://psutil.readthedocs.io/en/latest/#development-guide-1)

如果你想开发psutil，先看看[开发指南](https://github.com/giampaolo/psutil/blob/master/docs/DEVGUIDE.rst).

## **平台支持历史** (Platforms support history)

参考: [原文](https://psutil.readthedocs.io/en/latest/#platforms-support-history)

* psutil 5.8.1 (2021-10): MidnightBSD
* psutil 5.8.0 (2020-12): PyPy 2 on Windows
* psutil 5.7.1 (2020-07): Windows Nano
* psutil 5.7.0 (2020-02): drop Windows XP & Server 2003 support
* psutil 5.7.0 (2020-02): PyPy 3 on Windows
* psutil 5.4.0 (2017-11): AIX
* psutil 3.4.1 (2016-01): NetBSD
* psutil 3.3.0 (2015-11): OpenBSD
* psutil 1.0.0 (2013-07): Solaris
* psutil 0.1.1 (2009-03): FreeBSD
* psutil 0.1.0 (2009-01): Linux, Windows, macOS

支持的python版本是 `2.6`, `2.7`, `3.4+` 和 `PyPy3`.

## **时间线** (Timeline)

参考: [原文](https://psutil.readthedocs.io/en/latest/#timeline)

* 2020-12-19: [5.8.0](https://pypi.org/project/psutil/5.8.0/#files) - [what’s new](https://github.com/giampaolo/psutil/blob/master/HISTORY.rst#580) - [diff](https://github.com/giampaolo/psutil/compare/release-5.7.3...release-5.8.0#files_bucket)
* 2020-10-23: 5.7.3 - what’s new - diff
* 2020-07-15: 5.7.2 - what’s new - diff
* 2020-07-15: 5.7.1 - what’s new - diff
* 2020-02-18: 5.7.0 - what’s new - diff
* 2019-11-26: 5.6.7 - what’s new - diff
* 2019-11-25: 5.6.6 - what’s new - diff
* 2019-11-06: 5.6.5 - what’s new - diff
* 2019-11-04: 5.6.4 - what’s new - diff
* 2019-06-11: 5.6.3 - what’s new - diff
* 2019-04-26: 5.6.2 - what’s new - diff
* 2019-03-11: 5.6.1 - what’s new - diff
* 2019-03-05: 5.6.0 - what’s new - diff
* 2019-02-15: 5.5.1 - what’s new - diff
* 2019-01-23: 5.5.0 - what’s new - diff
* 2018-10-30: 5.4.8 - what’s new - diff
* 2018-08-14: 5.4.7 - what’s new - diff
* 2018-06-07: 5.4.6 - what’s new - diff
* 2018-04-14: 5.4.5 - what’s new - diff
* 2018-04-13: 5.4.4 - what’s new - diff
* 2018-01-01: 5.4.3 - what’s new - diff
* 2017-12-07: 5.4.2 - what’s new - diff
* 2017-11-08: 5.4.1 - what’s new - diff
* 2017-10-12: 5.4.0 - what’s new - diff
* 2017-09-10: 5.3.1 - what’s new - diff
* 2017-09-01: 5.3.0 - what’s new - diff
* 2017-04-10: 5.2.2 - what’s new - diff
* 2017-03-24: 5.2.1 - what’s new - diff
* 2017-03-05: 5.2.0 - what’s new - diff
* 2017-02-07: 5.1.3 - what’s new - diff
* 2017-02-03: 5.1.2 - what’s new - diff
* 2017-02-03: 5.1.1 - what’s new - diff
* 2017-02-01: 5.1.0 - what’s new - diff
* 2016-12-21: 5.0.1 - what’s new - diff
* 2016-11-06: 5.0.0 - what’s new - diff
* 2016-10-05: 4.4.2 - what’s new - diff
* 2016-10-25: 4.4.1 - what’s new - diff
* 2016-10-23: 4.4.0 - what’s new - diff
* 2016-09-01: 4.3.1 - what’s new - diff
* 2016-06-18: 4.3.0 - what’s new - diff
* 2016-05-14: 4.2.0 - what’s new - diff
* 2016-03-12: 4.1.0 - what’s new - diff
* 2016-02-17: 4.0.0 - what’s new - diff
* 2016-01-20: 3.4.2 - what’s new - diff
* 2016-01-15: 3.4.1 - what’s new - diff
* 2015-11-25: 3.3.0 - what’s new - diff
* 2015-10-04: 3.2.2 - what’s new - diff
* 2015-09-03: 3.2.1 - what’s new - diff
* 2015-09-02: 3.2.0 - what’s new - diff
* 2015-07-15: 3.1.1 - what’s new - diff
* 2015-07-15: 3.1.0 - what’s new - diff
* 2015-06-18: 3.0.1 - what’s new - diff
* 2015-06-13: 3.0.0 - what’s new - diff
* 2015-02-02: 2.2.1 - what’s new - diff
* 2015-01-06: 2.2.0 - what’s new - diff
* 2014-09-26: 2.1.3 - what’s new - diff
* 2014-09-21: 2.1.2 - what’s new - diff
* 2014-04-30: 2.1.1 - what’s new - diff
* 2014-04-08: 2.1.0 - what’s new - diff
* 2014-03-10: 2.0.0 - what’s new - diff
* 2013-11-25: 1.2.1 - what’s new - diff
* 2013-11-20: 1.2.0 - what’s new - diff
* 2013-10-22: 1.1.2 - what’s new - diff
* 2013-10-08: 1.1.1 - what’s new - diff
* 2013-09-28: 1.1.0 - what’s new - diff
* 2013-07-12: 1.0.1 - what’s new - diff
* 2013-07-10: 1.0.0 - what’s new - diff
* 2013-05-03: 0.7.1 - what’s new - diff
* 2013-04-12: 0.7.0 - what’s new - diff
* 2012-08-16: 0.6.1 - what’s new - diff
* 2012-08-13: 0.6.0 - what’s new - diff
* 2012-06-29: 0.5.1 - what’s new - diff
* 2012-06-27: 0.5.0 - what’s new - diff
* 2011-12-14: 0.4.1 - what’s new - diff
* 2011-10-29: 0.4.0 - what’s new - diff
* 2011-07-08: 0.3.0 - what’s new - diff
* 2011-03-20: 0.2.1 - what’s new - diff
* 2010-11-13: 0.2.0 - what’s new - diff
* 2010-03-02: 0.1.3 - what’s new - diff
* 2009-05-06: 0.1.2 - what’s new - diff
* 2009-03-06: 0.1.1 - what’s new - diff
* 2009-01-27: 0.1.0 - what’s new - diff

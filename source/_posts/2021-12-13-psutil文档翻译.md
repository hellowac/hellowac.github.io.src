---
title: psutil文档翻译
date: 2021-12-13 15:52:58
tags:
  - python
  - psutil
  - 翻译
  - 文档
categories:
  - 后端
  - 文档翻译
---

英文原文: <https://psutil.readthedocs.io/en/latest/#>

## psutil documentation

### 快速链接

原文: <https://psutil.readthedocs.io/en/latest/#quick-links>

* [Home page](https://github.com/giampaolo/psutil)
* [Install](https://github.com/giampaolo/psutil/blob/master/INSTALL.rst)
* [Forum](http://groups.google.com/group/psutil/topics)
* [Download](https://pypi.org/project/psutil/#files)
* [Blog](https://gmpy.dev/tags/psutil)
* [Contributing](https://github.com/giampaolo/psutil/blob/master/CONTRIBUTING.md)
* [Development guide](https://github.com/giampaolo/psutil/blob/master/docs/DEVGUIDE.rst)
* [What’s new](https://github.com/giampaolo/psutil/blob/master/HISTORY.rst)

### 关于 (About)

原文: <https://psutil.readthedocs.io/en/latest/#about>

psutil (python system and process utilities) is a cross-platform library for retrieving information on running **processes** and **system utilization** (CPU, memory, disks, network, sensors) in **Python**. It is useful mainly for **system monitoring**, **profiling**, **limiting process resources** and the **management of running processes**. It implements many functionalities offered by UNIX command line tools such as: `ps`, `top`, `lsof`, `netstat`, `ifconfig`, `who`, `df`, `kill`, `free`, `nice`, `ionice`, `iostat`, `iotop`, `uptime`, `pidof`, `tty`, `taskset`, `pmap`. psutil 目前支持下面这些平台:

* **Linux**
* **Windows**
* **macOS**
* **FreeBSD**, **OpenBSD**, **NetBSD**
* **Sun Solaris**
* **AIX**

支持的Python版本是 **2.6**, **2.7** 和 **3.4+**. [PyPy](http://pypy.org/) 也可以工作.

你正在读的psutil文档是作为单个HTML页面分发(发布)的。

### 基金 (Funding)

While psutil is free software and will always be, the project would benefit immensely from some funding. Keeping up with bug reports and maintenance has become hardly sustainable for me alone in terms of time. If you’re a company that’s making significant use of psutil you can consider becoming a sponsor via [GitHub](https://github.com/sponsors/giampaolo), [Open Collective](https://opencollective.com/psutil) or [PayPal](https://www.paypal.com/cgi-bin/webscr?cmd=_s-xclick&hosted_button_id=A9ZS7PKKRM3S8) and have your logo displayed in here and psutil [doc](https://psutil.readthedocs.io/).

#### 赞助 (Sponsors)

<div>
    <a href="https://tidelift.com/subscription/pkg/pypi-psutil?utm_source=pypi-psutil&amp;utm_medium=referral&amp;utm_campaign=readme">
        <img width="185" src="https://github.com/giampaolo/psutil/raw/master/docs/_static/tidelift-logo.svg?s=185&v=4">
    </a>
    &nbsp;&nbsp;
    <a href="https://sansec.io/">
        <img src="https://sansec.io/assets/images/logo.svg">
    </a>
</div>

添加你的[logo](https://github.com/sponsors/giampaolo)

#### 支持 (Supporters)

[![dbwiddis](https://avatars1.githubusercontent.com/u/9291703?s=44&v=4)](https://github.com/dbwiddis)
[![aristocratos](https://avatars3.githubusercontent.com/u/59659483?s=44&v=4)](https://github.com/aristocratos)
[![cybersecgeek](https://avatars.githubusercontent.com/u/12847926?s=44&v=4)](https://github.com/cybersecgeek)
[![scoutapm sponsorships](https://avatars.githubusercontent.com/u/71095532?s=44&v=4)](https://github.com/scoutapm-sponsorships)
[![chenyoo hao](https://images.opencollective.com/chenyoo-hao/avatar/40.png?s=44&v=4)](https://opencollective.com/chenyoo-hao)
[![alexey vazhnov](https://images.opencollective.com/alexey-vazhnov/daed334/avatar/40.png?s=44&v=4)](https://opencollective.com/alexey-vazhnov)

添加你的[头像](https://github.com/sponsors/giampaolo)

### 安装 (Install)

原文: <https://psutil.readthedocs.io/en/latest/#install-1>

在 Linux, Windows, macOS:

```shell
pip install psutil
```

对于其他平台，请参阅更详细的[安装说明](https://github.com/giampaolo/psutil/blob/master/INSTALL.rst)

## 系统相关函数 (System related functions)

原文: <https://psutil.readthedocs.io/en/latest/#system-related-functions>

### CPU (cpu)

原文: <https://psutil.readthedocs.io/en/latest/#cpu>

#### cpu_times

原文: <https://psutil.readthedocs.io/en/latest/#psutil.cpu_times>

**psutil.cpu_times(percpu=False)**:

Return system CPU times as a named tuple. Every attribute represents the seconds the CPU has spent in the given mode. The attributes availability varies depending on the platform:

* **user**: time spent by normal processes executing in user mode; on Linux this also includes guest time
* **system**: time spent by processes executing in kernel mode
* **idle**: time spent doing nothing

Platform-specific fields:

* **nice** (UNIX): time spent by niced (prioritized) processes executing in user mode; on Linux this also includes guest_nice time
* **iowait** (Linux): time spent waiting for I/O to complete. This is not accounted in idle time counter.
* **irq** (Linux, BSD): time spent for servicing hardware interrupts
* **softirq** (Linux): time spent for servicing software interrupts
* **steal** (Linux 2.6.11+): time spent by other operating systems running in a virtualized environment
* **guest** (Linux 2.6.24+): time spent running a virtual CPU for guest operating systems under the control of the Linux kernel
* **guest_nice** (Linux 3.2.0+): time spent running a niced guest (virtual CPU for guest operating systems under the control of the Linux kernel)
* **interrupt** (Windows): time spent for servicing hardware interrupts ( similar to “irq” on UNIX)
* **dpc** (Windows): time spent servicing deferred procedure calls (DPCs); DPCs are interrupts that run at a lower priority than standard interrupts.

When percpu is True return a list of named tuples for each logical CPU on the system. First element of the list refers to first CPU, second element to second CPU and so on. The order of the list is consistent across calls. Example output on Linux:

```python
>>> import psutil
>>> psutil.cpu_times()
scputimes(user=17411.7, nice=77.99, system=3797.02, idle=51266.57, iowait=732.58, irq=0.01, softirq=142.43, steal=0.0, guest=0.0, guest_nice=0.0)
```

Changed in version 4.1.0: added interrupt and dpc fields on Windows.

:::warning
CPU times are always supposed to increase over time, or at least remain the same, and that’s because time cannot go backwards. Surprisingly sometimes this might not be the case (at least on Windows and Linux), see [#1210](https://github.com/giampaolo/psutil/issues/1210#issuecomment-363046156).
:::

#### cpu_percent

原文: <https://psutil.readthedocs.io/en/latest/#psutil.cpu_percent>

**psutil.cpu_percent(interval=None, percpu=False)**:

Return a float representing the current system-wide CPU utilization as a percentage. When interval is > 0.0 compares system CPU times elapsed before and after the interval (blocking). When interval is 0.0 or None compares system CPU times elapsed since last call or module import, returning immediately. That means the first time this is called it will return a meaningless 0.0 value which you are supposed to ignore. In this case it is recommended for accuracy that this function be called with at least 0.1 seconds between calls. When percpu is True returns a list of floats representing the utilization as a percentage for each CPU. First element of the list refers to first CPU, second element to second CPU and so on. The order of the list is consistent across calls.

```python
>>> import psutil
>>> # blocking
>>> psutil.cpu_percent(interval=1)
2.0
>>> # non-blocking (percentage since last call)
>>> psutil.cpu_percent(interval=None)
2.9
>>> # blocking, per-cpu
>>> psutil.cpu_percent(interval=1, percpu=True)
[2.0, 1.0]
>>>
```

:::warning
the first time this function is called with interval = 0.0 or None it will return a meaningless 0.0 value which you are supposed to ignore.
:::

#### cpu_times_percent

原文: <https://psutil.readthedocs.io/en/latest/#psutil.cpu_times_percent>

**psutil.cpu_times_percent(interval=None, percpu=False)**:

Same as cpu_percent() but provides utilization percentages for each specific CPU time as is returned by psutil.cpu_times(percpu=True). interval and percpu arguments have the same meaning as in cpu_percent(). On Linux “guest” and “guest_nice” percentages are not accounted in “user” and “user_nice” percentages.

:::warning
the first time this function is called with interval = 0.0 or None it will return a meaningless 0.0 value which you are supposed to ignore.
:::

:::tip
Changed in version 4.1.0: two new interrupt and dpc fields are returned on Windows.
:::

#### cpu_count

原文: <https://psutil.readthedocs.io/en/latest/#psutil.cpu_count>

**psutil.cpu_count(logical=True)**:

Return the number of logical CPUs in the system (same as os.cpu_count in Python 3.4) or None if undetermined. “logical CPUs” means the number of physical cores multiplied by the number of threads that can run on each core (this is known as Hyper Threading). If logical is False return the number of physical cores only, or None if undetermined. On OpenBSD and NetBSD psutil.cpu_count(logical=False) always return None. Example on a system having 2 cores + Hyper Threading:

```python
>>> import psutil
>>> psutil.cpu_count()
4
>>> psutil.cpu_count(logical=False)
2
```

Note that psutil.cpu_count() may not necessarily be equivalent to the actual number of CPUs the current process can use. That can vary in case process CPU affinity has been changed, Linux cgroups are being used or (in case of Windows) on systems using processor groups or having more than 64 CPUs. The number of usable CPUs can be obtained with:

```python
>>> len(psutil.Process().cpu_affinity())
1
psutil.cpu_stats()
```

#### cpu_stats

原文: <https://psutil.readthedocs.io/en/latest/#psutil.cpu_stats>

**psutil.cpu_stats()**:

Return various CPU statistics as a named tuple:

* **ctx_switches**: number of context switches (voluntary + involuntary) since boot.
* **interrupts**: number of interrupts since boot.
* **soft_interrupts**: number of software interrupts since boot. Always set to 0 on Windows and SunOS.
* **syscalls**: number of system calls since boot. Always set to 0 on Linux.

Example (Linux):

```python
>>> import psutil
>>> psutil.cpu_stats()
scpustats(ctx_switches=20455687, interrupts=6598984, soft_interrupts=2134212, syscalls=0)
```

:::tip
New in version 4.1.0.
:::

#### cpu_freq

原文: <https://psutil.readthedocs.io/en/latest/#psutil.cpu_freq>

**psutil.cpu_freq(percpu=False)**:

Return CPU frequency as a named tuple including current, min and max frequencies expressed in Mhz. On Linux current frequency reports the real-time value, on all other platforms it represents the nominal “fixed” value. If percpu is True and the system supports per-cpu frequency retrieval (Linux only) a list of frequencies is returned for each CPU, if not, a list with a single element is returned. If min and max cannot be determined they are set to 0.

Example (Linux):

```python
>>> import psutil
>>> psutil.cpu_freq()
scpufreq(current=931.42925, min=800.0, max=3500.0)
>>> psutil.cpu_freq(percpu=True)
[scpufreq(current=2394.945, min=800.0, max=3500.0),
 scpufreq(current=2236.812, min=800.0, max=3500.0),
 scpufreq(current=1703.609, min=800.0, max=3500.0),
 scpufreq(current=1754.289, min=800.0, max=3500.0)]
```

可用平台: Linux, macOS, Windows, FreeBSD

5.1.0 版本中新增。

5.5.1 版本中更新：添加了 FreeBSD 支持。

#### getloadavg

原文: <https://psutil.readthedocs.io/en/latest/#psutil.getloadavg>

**psutil.getloadavg()**:

Return the average system load over the last 1, 5 and 15 minutes as a tuple. The “load” represents the processes which are in a runnable state, either using the CPU or waiting to use the CPU (e.g. waiting for disk I/O). On UNIX systems this relies on os.getloadavg. On Windows this is emulated by using a Windows API that spawns a thread which keeps running in background and updates results every 5 seconds, mimicking the UNIX behavior. Thus, on Windows, the first time this is called and for the next 5 seconds it will return a meaningless (0.0, 0.0, 0.0) tuple. The numbers returned only make sense if related to the number of CPU cores installed on the system. So, for instance, a value of 3.14 on a system with 10 logical CPUs means that the system load was 31.4% percent over the last N minutes.

```python
>>> import psutil
>>> psutil.getloadavg()
(3.14, 3.89, 4.67)
>>> psutil.cpu_count()
10
>>> # percentage representation
>>> [x / psutil.cpu_count() * 100 for x in psutil.getloadavg()]
[31.4, 38.9, 46.7]

```

可用平台: Unix, Windows

5.6.2 版本中新增。

### 内存 (Memory)

#### virtual_memory

### swap_memory

### 磁盘 (Disks)

#### disk_partitions

#### disk_usage

#### disk_io_counters

### 网络 (Network)

#### net_io_counters

#### net_connections

#### net_if_addrs

#### net_if_stats

### 传感器 (Sensors)

#### sensors_temperatures

#### sensors_fans

#### sensors_battery

### 其他系统信息(Other system info)

#### boot_time

#### users

## 进程 (Processes)

### 函数 (Functions)

#### pids

#### process_iter

#### pid_exists

#### wait_procs

### 异常 (Exceptions)

#### Error

#### NoSuchProcess

#### ZombieProcess

#### AccessDenied

#### TimeoutExpired

### 进程类 (Process class)

#### Process

##### oneshot

##### pid

##### ppid

##### name

##### exe

##### cmdline

##### environ

##### create_time

##### as_dict

##### parent

##### parents

##### status

##### cwd

##### username

##### uids

##### gids

##### terminal

##### nice

##### ionice

##### rlimit

##### io_counters

##### num_ctx_switches

##### num_fds

##### num_handles

##### num_threads

##### threads

##### cpu_times

##### cpu_percent

##### cpu_affinity

##### cpu_num

##### memory_info

##### memory_info_ex

##### memory_full_info

##### memory_percent

##### memory_maps

##### children

##### open_files

##### connections

##### is_running

##### send_signal

##### suspend

##### resume

##### terminate

##### kill

##### wait

#### Popen

## windows 服务 (Windows services)

### win_service_iter

### win_service_get

### WindowsService

#### name

#### display_name

#### binpath

#### username

#### start_type

#### pid

#### status

#### description

#### as_dict

## 常量 (Constants)

### 操作系统常量

#### POSIX

#### LINUX

#### WINDOWS

#### MACOS

#### FREEBSD
